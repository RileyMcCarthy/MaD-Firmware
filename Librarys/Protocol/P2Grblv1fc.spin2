  '' =================================================================================================
''
''   File....... P2Grblv1fb.spin2
''   Purpose.... GRBL like G-code motion controller for step/dir stepper motors
''               works with "Universal Gcode Sender" shareware, or with parallax serial terminal
''               It can also stream a G-code file that it reads into "text" in it's DAT area.
''               There is also a AUTOMATIC template which lets you run a a part program routine with
''               capability to substitute variables into the G-code commands.
''   Author..... Mike Roberts
''               Copyright (c) 2020 Mike Roberts
''               -- see below for terms of use
''   E-mail..... mikermeister2@gmail.com
''   Started.... December 2020
''   Updated.... 13 2 2021
''   Updated     4/27/2021
''   use a pasm cog to do the pulse loop and calculate positions
''   calculates position every 10uSec and if pulses not equil to position, outputs a step.
''   adding in exact stop
''   send over move +/- sign
''   start working on circular interpolation
''   add G02 to general CNC method
''   add A axis
''   embedding g02/g03 into main cnc move generator
''   working on grbl emulation
''   making move buffer 4/19/21
''   remove velocity calculation in PASM to allow scaling of axis pulses 4/20/2021
''   scaling values sent over in what was velocity dat.
''   can send something back from PASM now in what were velocity datas
''   added "move active", "decel active" status bits back from PASM
''
''  pulses per mm... $100,$101,$102 done 2/20/2021
''  G4 dwell implemented
''  G02 and G03 parsing i,j,k center, still need R nomenclature
''  move buffer done
''  feed rate override done
''  incremental and absolute coordinates... 5/3/2021
''  G09 exact stop moves added back 5/4/2021
''  make PASM smaller
 '' use indirect addressing to shrink step/dir output code...  5/7/2021
''  prior Dat size 1980
''  New Dat size 1820           40 32bit words less....   about 60 instructions or vars left   10%?
''  moved PASM routines up into LUT area, freed up lots of space, cleaned up code and readability
''  added "skip rest of move" bit from report() to PASM, this will work for probing and homeing
''  5/23/2021 v1ed changing parse() so it takes a string pointer and also parses a string down completely
''  5/24/2021 probing and homeing working
''  5/27/2001 changed parse so that Parse() adds move to move buffer, not up a level in Report(),
''  this lets a method call Parse() severl times in a row to add moves to the move buffer.
''  5/27/2021 Added G92 coordinate preset functionality
''  5/28/2021 Added bit masks for direction (cw/ccw) of stepper driver direction pins...
''  6/2 changed LUT loader, pulsesLUT skpdir SKIP , working on reading moves from inported text file
''  6/4 reads in moves from g-code text file, starts streaming with a ctrl-F untill <EOF> $F8 is read
''
''  Too Do:
''  Metric to inch  , G20 multiply input by 25.4?   1->1000 so 1->25400... inch inputs 4 decimals?
''  G00 rapid moves
''  just parse mode
''  better parse error handling
''  work coordinates
''  error handeling
''  add g18 and g19 planes for circular motion
''  add z motion when doing g17 x,y circular motion
''  spindle control?? extruder control?? laser control??
''  Add 5th axis
''
'' =================================================================================================



CON

  CLK_FREQ = 200_000_000                                        ' system freq as a constant
  MS_001   = CLK_FREQ / 1_000                                   ' ticks in 1ms
  US_001   = CLK_FREQ / 1_000_000

  _clkfreq = 200_000_000
  CONSTANT_NAME = 0
  baud  = 115_200
  #0, T_PST, T_ANSI                                             ' terminal types
  T_TYPE = T_ANSI

  Bit0 = %0000_0001
  Bit1 = %0000_0010
  Bit2 = %0000_0100
  Bit3 = %0000_1000
  Bit4 = %0001_0000
  Bit5 = %0010_0000
  Bit6 = %0100_0000
  Bit7 = %1000_0000

  Bit8  = %0001_0000_0000
  Bit9  = %0010_0000_0000
  Bit10 = %0100_0000_0000
  Bit11 = %1000_0000_0000

  Bit12  = %0001_0000_0000_0000
  Bit13  = %0010_0000_0000_0000
  Bit14  = %0100_0000_0000_0000
  Bit15  = %1000_0000_0000_0000

  Bit16  = %0001_0000_0000_0000_0000
  Bit17  = %0010_0000_0000_0000_0000
  Bit18  = %0100_0000_0000_0000_0000
  Bit19  = %1000_0000_0000_0000_0000


''AckOut bit meanings'''''''''''''''''
  GOTmove =Bit0     'used on Ack_out
  ACTmov  =Bit1     'used on Ack_out
  ACTdec  =Bit2     'used on Ack_out


  Xhomed  =Bit7     'used on Ack_out
  Yhomed  =Bit8     'used on Ack_out
  Zhomed  =Bit9     'used on Ack_out
  Ahomed  =Bit10    'used on Ack_out


  transbit  = Bit16   'weather to skip move on low to high transition or high to low transition
  zeroaxbit = Bit17   'weather to zero axis position on probe/skip input detection
  skipbit   = Bit18   'G38.2,G38.3,G38.4,orG38.5 probe/skip move active



'''parser inputs[] bit meanings'''''''''''''''''
  Inin    = Bit1     'G20,G21 inch or metric mode
  Xin     = Bit2     'if xvalue[] is zero, need to know if it was written that way... for G90ABS mode
  Yin     = Bit3
  Zin     = Bit4
  Ain     = Bit5
  Iin     = Bit6
  Jin     = Bit7
  Kin     = Bit8
  Rin     = Bit9
  Sin     = Bit10
  Tin     = Bit11
  Fin     = Bit12
  Pin     = Bit13
  gMin    = Bit14       'G0,G1,G2,G3,G4 move type
  gPin    = Bit15       'G17,G18,G19 G02,G03 Plane
  ABSin   = Bit16       'G90-G91 Absolute or incremental
  ExStopb = Bit17       'exact stop


''''Ack_in bit meanings''''''''''''''''
  movRDY  =Bit0     'used on Ack_in '
  Fhold   =Bit1     'used on Ack_in
  SoftRS  =Bit2     'used on Ack_in
  SkipM   =Bit3     'used on ACK_in


  Xhome   = Bit7     'used on Ack_in
  Yhome   = Bit8     'used on Ack_in
  Zhome   = Bit9     'used on Ack_in
  Ahome   = Bit10    'used on Ack_in
  Bhome   = Bit11

  Zero_X  = Bit12
  Zero_Y  = Bit13
  Zero_Z  = Bit14
  Zero_A  = Bit15
  Zero_B  = Bit16

  xHiLmtPin = 16
  xLoLmtPin = 17
  yHiLmtPin = 18
  yLoLmtPin = 19
  zHiLmtPin = 20
  zLoLmtPin = 21
  aHiLmtPin = 22
  aLoLmtPin = 23
  bHiLmtPin = 22
  bLoLmtPin = 23
  Probe1Pin = 24
  Probe2Pin = 25


VAR

  '''''''''''''''These vars come from the <-PASM routine every 10uSec'''''''''''''''''''''''
  long Xpos,Ypos,Zpos,Apos     'Axis positions
  long Xvel,Yvel,Zvel,Avel
  long Ack_out            'PASM sets bit #0 high to ack new move read in

  '''''''''''''''These vars go to the -> PASM routine when there is a move to send''''''''''
  '''''''''''''''Ack_in gets checked by PASM every 10uSec'''''''''''''''''''''''''''''''''''
  long Xmove,Ymove,Zmove,Amove  'move distance
  long Blocktime          'Blocktime -> (vector move distance)/(feedrate)
  long AccTC              'acceleration time constant (time to transition from current feedrate to the next feedrate)
  long Ack_in             'PASM checks bit #0 every 10uSec for a new move to read in
  long AccDisX,AccDisY,AccDisZ,AccDisA
  long SqTC
  long ExStop
  long Sign
  long Xscale,Yscale,Zscale,Ascale
  long StT,EndT,DisT,OffsetX,OffsetY,AccDisT,Rad
  long Delay

  ''''''''''''''These vars are used in the Spin routines''''''''''''''''''''''''''''''''''
  long movelength        'move vector length... sqrt of sum of squares...
  long spiral
  long line
  long peek
  long say_ok
  long MoveType,LastMtype,Absolute,Coordinates,Units,gValue,mValue,eValue
  long gMtype[100],gAbs[100],gPlane[100]
  long gUnits[100],gCoord[100]
  long xvalue[100],yvalue[100],zvalue[100],avalue[100]
  long ivalue[100],jvalue[100],kvalue[100],rvalue[100]
  long svalue[100],tvalue[100],fvalue[100],pvalue[100]
  long inputs[100],skips[100] 'bits that tell if when a line is parsed, if there was a x input, y input, etc...
  long global_feed
  long buff_tail,buff_head,buffered
  long idx
  long XhiLMT,XloLMT,YhiLMT,YloLMT,ZhiLMT,ZloLMT,AhiLMT,AloLMT
  long new_move,get_move
  long error
  byte c
  byte ex1
  byte ex2
  byte ex3

  long FroF,FroR,FroS 'feed rate overides for Feed, Rapid and Spindle

  long GrblState     '0-Idle,1-Run,2-Hold:0,3-Hold:1,4-Jog,5-Alarm,6-Door:0,7-Door:1,
                     '8-Door:2,9-Door:3,10-Check,11-Home,12-Sleep
  long UpdateFlags   'Bit0-State,Bit1-work offsets,Bit2-buffer status,Bit3-feed/speed,Bit4-feed overides
                     'Bit5-Accessorys,Bit6-input pin states
  long UpdateCnt

  long AbsX,AbsY,AbsZ,AbsA
  long ABS_G90
  long G09 'exact stop move

  long ParGrbl[150]  'Grbl parameters
  byte ParFmt[40]
  byte Pnum[40]

  byte in_str[128]
  long in_ptr
  long gp_ptr
  long st_idx
  long tPTR3
  long tPTR4
  long tPTR5
  byte teststr[128]

  long Homed
  long Homing
  long HomingStage
  long StreamTxt
  long HeadPtr,TailPtr

  long cogstack1[4000]    'stack for report
DAT
leftstr  byte "g38.2g91g1x.25f50",0    'lower case
rightstr byte "g91g1x-.25f50",0
refxstr  byte "g38.2g91g1x5.25f50",0
upstr    byte  "g91y10f30",0
tempstr  byte 0[128]
tempstr2 byte 0[128]
tempstr3 byte 0[128]
tempstr4 byte 0[128]
         'orgh  $a000
text     file "parallax3kROM2.nc" '"biggcode.txt"
textend
OBJ
   term : "jm_fullduplexserial"
   fmt  : "jm_nstr"

PUB main() | Xinc,Yinc,Zinc,Ainc


   Blocktime := 100_000    ' one second with Pulse() looping at 100_000 per sec
   AccTC     :=  2000 '20_000    '200mSec acceleration time constant, ok to set between 20mSec and 640mSec
   SqTC := AccTC * AccTC
   Ack_in := 0
   Ack_out := 0
   in_str[0]:= 0
   in_ptr := @in_str
   gp_ptr := @in_str                       'your move blocktime should be longer than the AccTC
   ClearBuffer()
   Homed := false
   Homing := false
   FroF := 100
   FroR := 100
   FroS := 100
   Delay := 2000
   Line := 0
   ABS_G90 := true
   AbsX,AbsY,AbsZ,AbsA := 0,0,0,0
   Xpos,Ypos,Zpos,Apos := 0,0,0,0
   Xvel,Yvel,Zvel,Avel := 0,0,0,0
   Xmove,Ymove,Zmove,Amove := 0,0,0,0
   AccDisX,AccDisY,AccDisZ,AccDisA,AccDisT := 0,0,0,0,0
   Xscale := 80_000   '1_000_000 -> 1000 steps per mm, use 80_000 for X axis on creality ender 3
   Yscale := 80_000   '80_000 for Y axis on creality ender 3
   Zscale := 400_000  '400_000 for Z axis on creality ender 3
   Ascale := 93_000   '93_000 for extruder axis on creality ender 3
   XhiLmt :=  10000_00
   XloLmt := -10000_00
   YhiLmt :=  10000_00
   YloLmt := -10000_00
   ZhiLmt :=  10000
   ZloLmt := -10000
   AhiLmt :=  10000
   AloLmt := -10000

   repeat idx from 0 to 99
      fvalue[idx] := -1
      gMtype[idx] := -1

   PullUpLimits() 'limits pulled high with 15k, switch to ground to pull low
   buff_head := 0
   buff_tail := 0
   Buffered  := 0

   Xpos := @LutCall   'LUT routine hub addresses so PASM can load programs into LUT on startup
    coginit(16,@Pulse2,@Xpos)           ''''''Start 100_000hz pasm pulse interpolation loop''''''''''''''''''''''''''
    cogspin(16,Report(),@cogstack1)     ''''''Report handles communication with "Universal G-code Sender" or whatever
    'coginit(16,@Pulse2,@Xpos)           ''''''Start 100_000hz pasm pulse interpolation loop''''''''''''''''''''''''''
    'waitms(100) 'wait for cog to spin up
    StartUp()
    Global_feed := 200
    MoveType := 1 ' G00, G01, G02, G03
    LastMtype := 1
    Units := 21   ' G20=inch G21=mm
    Absolute := 90  'G90=Absolute G91=Incremental
    'Plane := 17     'G17=X,Y


    repeat
                 'wait for move in buffer or soft reset to end or skip to end
      repeat while (buff_tail == buff_head) or ((Ack_in & softRS)==softRS) or ((Ack_in & SkipM)==SkipM)

      if (fvalue[buff_tail] <> -1)
        global_feed := fvalue[buff_tail]


      if ((inputs[Buff_tail] & ABSin) == ABSin)
             case gABS[buff_tail]
                   90 : ABS_G90 := true
                   91 : ABS_G90 := false

      case gMtype[buff_tail]
         0   : MoveType := 0
               LastMtype := 0
         1   : MoveType := 1
               LastMtype := 1
         2   : MoveType := 2
               LastMtype := 2
         3   : MoveType := 3
               LastMtype := 3
         4   : MoveType := 4
         92  : MoveType := 92
       other : MoveType := LastMtype

      if (MoveType <> 92) 'G92 resets coordinates
        if ABS_G90    'convert everything to incremental
           if ((inputs[Buff_tail] & Xin) == Xin)
                     Xinc :=  xvalue[buff_tail] - AbsX
           if ((inputs[Buff_tail] & Yin) == Yin)
                     Yinc :=  yvalue[buff_tail] - AbsY
           if ((inputs[Buff_tail] & Zin) == Zin)
                     Zinc :=  zvalue[buff_tail] - AbsZ
           if ((inputs[Buff_tail] & Ain) == Ain)
                     Ainc :=  avalue[buff_tail] - AbsA
        else
                     Xinc :=  xvalue[buff_tail]
                     Yinc :=  yvalue[buff_tail]
                     Zinc :=  zvalue[buff_tail]
                     Ainc :=  avalue[buff_tail]


        if ((inputs[Buff_tail] & ExStopb) == ExStopb) 'If Exact stop G9 on move line
           G09 := 1
        else
           G09 := 0

        AbsX := AbsX + Xinc    'keep a local absolute positions.
        AbsY := AbsY + Yinc    'The positions Xpos,Ypos,Zpos,Apos are realtime
        AbsZ := AbsZ + Zinc    'from the PASM, these, AbsX,AbsY,AbsZ,AbsA are to
        AbsA := AbsA + Ainc    'convert absolute moves to incremental moves
                             'so they contain the endpoints, not active motion.
                             'On soft reset or skip(probe,home), AbsX,AbsY,AbsZ,AbsA get set to Xpos,Ypos,Zpos
      case MoveType
        0 {G00}   : G01G91(Xinc,Yinc,Zinc,Ainc,global_feed,G09)
        1 {G01}   : G01G91(Xinc,Yinc,Zinc,Ainc,global_feed,G09)
        2 {G02}   : G02(Xinc,Yinc,ivalue[buff_tail],jvalue[buff_tail],rvalue[buff_tail],global_feed,G09)
        3 {G03}   : G03(Xinc,Yinc,ivalue[buff_tail],jvalue[buff_tail],rvalue[buff_tail],global_feed,G09)
        4 {G04}   : G04(pvalue[buff_tail])
        92{G92}   : G92(xvalue[buff_tail],yvalue[buff_tail],zvalue[buff_tail],avalue[buff_tail],inputs[buff_tail])


        'if((Ack_in & SkipM)<>SkipM) 'if skip, reload move to correct for new abs positions

      xvalue[buff_tail],yvalue[buff_tail],zvalue[buff_tail],avalue[buff_tail] := 0,0,0,0
      ivalue[buff_tail],jvalue[buff_tail],kvalue[buff_tail],rvalue[buff_tail] := 0,0,0,0
      Xinc,Yinc,Zinc,Ainc := 0,0,0,0
      fvalue[buff_tail],gMtype[buff_tail]  := -1,-1
      inputs[buff_tail] :=0 ' added on 6/7/2021
      skips[buff_tail] := 0 'added on 6/14/2021
      if ((Ack_in & softRS)<>softRS)   'if not soft reset
         say_ok := true     'Without this "ok" the g-code streamer will not stream new moves...
      buff_tail := buff_tail + 1
       if buff_tail > 99
             buff_tail := 0
      Buffered--  'buffered is just a count of the moves in the buffer
      if ((Ack_In & softRS) == softRS)          'check this...ugh...testing...
        ClearBuffer()
        Buff_Tail := Buff_Head
        Buffered := 0


PUB Report()|  strPTR ', index, tPTR1,headPTR,index2
  term.tstart(baud)
  term.str(string("Grbl 1.1h ['$' for help]",10)) '"ctrl x" soft reset
  repeat

      c := term.rxcheck()
      if c  <> 255
        if ((c >= "A") && (c <= "Z"))     'make all lower case as they are read in
          c += 32
       case c

         '13 :  'term.str(string("cr",13,10))


         10,13 : 'term.str(string("lf",13,10)) 'UGC sends out a <LF> termination?, serial terminal sends out a <CR>
              in_str[st_idx]:= 0 'line feed ends input string... set null termination
              st_idx := 0
              'repeat while (strsize(@in_str) > 0)
               ' term.str(@in_str)
               ' term.str(string(13,10))
              'parse3(@in_str)
              parse(@in_str)

              st_idx := 0


         $18:  'term.str(string("Grbl 1.1h ['$' for help]",10)) '"ctrl x" soft reset
               GrblState := 0 'Idle?? clear buffers and reset PASM pulse?
               Homing := false
               StreamTxT := false
               Ack_in := Ack_in | Bit2    'set Soft Reset bit
               term.str(string("Grbl 1.1h ['$' for help]",10)) '"ctrl x" soft reset
               GrblState := 0
               'Buff_Tail := Buff_Head
               Ack_in := Ack_in & !Bit1  'clear feed hold bit
               waitms(100)
               GrblState := 0
               AbsX := Xpos
               AbsY := Ypos
               AbsZ := Zpos
               AbsA := Apos
               Ack_in := Ack_in & !Bit2  'abort reset clear buffer bit
               'Ack_in := Ack_in & !Bit1  'clear feed hold bit

         "?":  RealTimeStatus()
               'term.str(@text)


         "<":  MDI(string("G91G1x0.25f50"))

         ">":  MDI(string("G91G1 x-.25 f50"))

         $6 :  '"CTRL-F" starts streaming g-code txt data in DAT to the motion buffer
               headPTR := @text
               StreamTxt := true

         $7 :  '"CTRL-G" starts Autocycle
               AutoCycle()


         "!":  if (Ack_Out & 6) <> 0
                 Ack_in := Ack_in | Bit1 'feed hold
                 GrblState := 2 ' "Hold:0"
                     '0-Idle,1-Run,2-Hold:0,3-Hold:1,4-Jog,5-Alarm,6-Door:0,7-Door:1,
                     '8-Door:2,9-Door:3,10-Check,11-Home,12-Sleep
                     'set the update mode bit
                     'Bit0-State,Bit1-work offsets,Bit2-buffer status,Bit3-feed/speed,Bit4-feed overides
                     'Bit5-Accessorys,Bit6-input pin states

         "~":  Ack_in := Ack_in &  !Bit1 '%11111111_11111111_11111111_11111101 'feed resume
               if (Ack_Out & 6) <> 0
                   GrblState := 1 '"Run"
               else
                   GrblState := 0 '"Idle"
                     '0-Idle,1-Run,2-Hold:0,3-Hold:1,4-Jog,5-Alarm,6-Door:0,7-Door:1,
                     '8-Door:2,9-Door:3,10-Check,11-Home,12-Sleep
                     'set the update mode bit
                     'Bit0-State,Bit1-work offsets,Bit2-b??uffer status,Bit3-feed/speed,Bit4-feed overides
                     'Bit5-Accessorys,Bit6-input pin states

         $90..$94: UpdateFlags := UpdateFlags | Bit4   'set the text output update mode bit for feed rate override change
                   case c
                        $90 : Ack_in := Ack_in &  !Fhold  'turn off feed hold
                              FroF := 100
                        $91 : Ack_in := Ack_in &  !Fhold  'turn off feed hold
                              if (FroF < 90) ' Add 10%
                                  FroF := FroF+10
                              else

                                  FroF := 100

                        $92 : if (Frof > 10) 'Decrease 10%
                                  Frof := FroF -10
                              else
                                  Frof := 0
                                  Ack_in := Ack_in | Fhold 'turn on feed hold
                                  GrblState := 2 ' "Hold:0"

                        $93 : Ack_in := Ack_in &  !Fhold
                              if (FroF < 99) ' Add 1%
                                  Frof := FroF+1
                              else
                                  Frof := 100

                        $94 : if (Frof > 1) 'Decrease 1%
                                  Frof := Frof -1
                              else
                                    Frof := 0
                                    Ack_in := Ack_in | Fhold 'turn on feed hold
                                    GrblState := 2 ' "Hold:0"
                                  'do feed hold here...

                   if (FroF > 0)
                      Delay := 200_000/FroF 'this will blow up if FroF=0




         other :   'this part reads chars into a string that gets sent to parse() after <CR> or <LF>
                   'case c
                   '1..20 : term.fstr1(string("%d"),c)
                   'other : term.tx(c)
                   if c <> " "          'if not a blank
                     in_str[st_idx] := c
                     st_idx++


     if(say_ok)  'MAIN must have just read the new move
           say_ok := false
           term.fstr4(string("head: %d , tail:%d, size:%d, line:%d",10),buff_head,buff_tail,Buffered,line)
           term.str(string("ok",13,10)) 'Without this "ok" the g-code streamer will not stream new moves..
     ChkSwLmts()
     if Homing
        Home()
     if StreamTxT
        StreamText()

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G01G91G09(x,y,z,a,feed)

    CNC(x,y,z,a,0,0,0,0,feed,0,1)
    'CNC(X,Y,Z,A,P,DegStart,DegMove,Radius,Feed,plane,pause)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G01G91(x,y,z,a,feed,xs)
    CNC(x,y,z,a,0,0,0,0,feed,0,xs)
    'CNC(X,Y,Z,A,P,DegStart,DegMove,Radius,Feed,plane,pause)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G02(x,y,i,j,r,f,xs)| bigstartangle,bigendangle,startangle,endangle,moveangle  'CW Arc

 r,bigstartangle := xypol(-i,-j)
 r,bigendangle   := xypol(x-i,y-j)

 startangle := muldiv64(bigstartangle,360_000,$ffff_ffff)
 endangle   := muldiv64(bigendangle,360_000,$ffff_ffff)

    if startangle > endangle
      moveangle := endangle - startangle
    else
      moveangle := (endangle-startangle)-360_000

    CNC(0,0,0,0,0,startangle,moveangle,r,f,0,xs)
    'CNC(X,Y,Z,A,P,DegStart,DegMove,Radius,Feed,plane,pause)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G03(x,y,i,j,r,f,xs)| bigstartangle,bigendangle,startangle,endangle,moveangle  'CCW Arc

 r,bigstartangle := xypol(-i,-j)
 r,bigendangle   := xypol(x-i,y-j)

 startangle := muldiv64(bigstartangle,360_000,$ffff_ffff)
 endangle   := muldiv64(bigendangle,360_000,$ffff_ffff)

    if startangle < endangle
      moveangle := endangle - startangle
    else
      moveangle := (endangle + 360_000)-startangle

    CNC(0,0,0,0,0,startangle,moveangle,r,f,0,xs)
    'CNC(X,Y,Z,A,P,DegStart,DegMove,Radius,Feed,plane,pause)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G04(p)| anyfeed      'G4 Delay
    anyfeed := 1000 'just so we don't get a divide by zero?
    CNC(0,0,0,0,p,0,0,0,anyfeed,0,0)
    'CNC(X,Y,Z,A,P,DegStart,DegMove,Radius,Feed,plane,pause)


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI G92(x,y,z,a,input)'set new coordinates to whatever you put in Xmove,Ymove,Zmove,Amove
    repeat while ((Ack_out & ACTmov)==ACTmov) or ((Ack_out & ACTdec)==ACTdec)  'wait till stopped movein
    if ((input & Xin) == Xin)
        Xmove := x
        Ack_in := Ack_in | Zero_X    'set "Preset_X" bit
        repeat while (Xpos <>x)
        AbsX := Xpos
        Ack_in := Ack_in & !Zero_X   'reset "Preset_X" bit
    if ((input & Yin) == Yin)
        Ymove := y
        Ack_in := Ack_in | Zero_Y    'set "Preset_Y" bit
        repeat while (Ypos <>y)
        AbsY := Ypos
        Ack_in := Ack_in & !Zero_Y   'reset "Preset_Y" bit
    if ((input & Zin) == Zin)
        Zmove := z
        Ack_in := Ack_in | Zero_Z    'set "Preset_Z" bit
        repeat while (Zpos <>z)
        AbsZ := Zpos
        Ack_in := Ack_in & !Zero_Z   'reset "Preset_Z" bit
    if ((input & Ain) == Ain)
        Amove := a
        Ack_in := Ack_in | Zero_A    'set "Preset_A" bit
        repeat while (Apos <>a)
        AbsA := Apos
        Ack_in := Ack_in & !Zero_A   'reset "Preset_A" bit

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI CNC(X,Y,Z,A,P,StartAng,MoveAng,Radius,Feed,Plane,Pause) | t1,t2,t3,EndAng,tmovelen,sAxis,PinS,transition,zeroaxis

       line++
       repeat while ((Ack_out&1) == 1)  'bitwise AND -> wait untill PASM has finished reading the prior move

       Xmove,Ymove,Zmove,Amove := 0,0,0,0
       AccDisX,AccDisY,AccDisZ,AccDisA,AccDisT := 0,0,0,0,0

       StT,EndT,DisT,OffsetX,OffsetY,Rad := 0,0,0,0,0,0

       Sign := %1_1111

       if MoveAng < 0                           ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
          -= MoveAng                            'If MoveAng is negative, it is a G02 CW move           '
          -=StartAng                            'If MoveAng is positive, it is a G03 CCW move          '
          StartAng := startang + 180_000        '                                                      '
          if StartAng < 0                       ''''''''''''''''''''''''''''''''''''''''''''''''''''''''
              StartAng := StartAng + 360_000
          Sign := %0_1111  'clear bit 4

       EndAng := StartAng + MoveAng
       StT      := MULDIV64(StartAng,$0FFF_FFFF,360_000)
       EndT     := MULDIV64(EndAng,$0FFF_FFFF,360_000)
       DisT     := MULDIV64(MoveAng,$0FFF_FFFF,360_000)
       t1       := MULDIV64(MoveAng,1000,57297) 'degrees to radians
       Tmovelen := MULDIV64(Radius,t1,1000) 'length = radius x radians
       t1 := StT
       t1<<=4
       OffsetX,OffsetY := ROTXY(Radius,0,t1)

       if ((sign & %1_0000) == 0)                        'this is for G02 CW rotation vs G03 CCW
          -= offsetX                                     'this is for G02 CW rotation vs G03 CCW

       Rad := Radius

      'movelength := sqrt((x*x)+(y*y)+(z*z)+(a*a)+(AngDis*AngDis))
       movelength := vectorlength(x,y)
       movelength := vectorlength(movelength,z)
       movelength := vectorlength(movelength,a)
       movelength := vectorlength(movelength,TmoveLen)

       t1 := 60_000   '1000 * 60 seconds per minute
       blocktime :=  MULDIV64(t1,movelength,feed)     '((1000*movelength)*60)/feed

       If blocktime <= AccTC                          'I don't like this and the next line, but...
          blocktime := AccTC + 1                      'blocktime shouldn't be less than AccTC

       t1 := blocktime << 1                           'this is the (1/2) term 8 lines down

       if (p<>0)                                      'if G4 Dwell do this
          blocktime := p*100 + AccTC                  '100_000 = 1 sec, 1000= 1 sec, so

       Xmove := x                 'feed is in mm/min
       Ymove := y                 '1000 pulses per mm
       Zmove := z                 'If move is 10mm, X= 10_000, feed is 1mm/min, this takes 10min
       Amove := A                 'blocktime = 60_000 x 10_000 / 1
       ABS=x                      'blocktime = 600_000_000 units of 10uSec (interp looptime)
       ABS=y                      '600_000_000/100_000 = 600 seconds, or 10 minutes.
       ABS=z
       ABS=a
       ExStop := pause
       AccDisX := MULDIV64(x,AccTC,t1)               'AccDisX = Xmove * (AccTC/Blocktime) * (1/2)
       AccDisY := MULDIV64(y,AccTC,t1)
       AccDisZ := MULDIV64(z,AccTC,t1)
       AccDisA := MULDIV64(a,AccTC,t1)
       AccDisT := MULDIV64(DisT,AccTC,t1)
       'Xv := MULDIV64(x,100_000,Blocktime)         'Xvelocity = (Xmove * 100_000)/Blocktime
       'Yv := MULDIV64(y,100_000,Blocktime)
       'Zv := MULDIV64(z,100_000,Blocktime)
       'Av := MULDIV64(a,100_000,Blocktime)



       if (Xmove<0)
          Sign := Sign & %1_1110            'X is a negative move
          -= AccDisX
       if (Ymove<0)
          Sign := Sign & %1_1101
          -= AccDisY
       if (Zmove<0)
          Sign := Sign & %1_1011
          -= AccDisZ
       if (Amove<0)
          Sign := Sign & %1_0111
          -= AccDisA

       Ack_in := Ack_in | movRDY                                 'Ack_into pasm that spin has a new move to be read!!!
       repeat until((Ack_out&1) == 1) or ((Ack_in & Bit2)==4) or ((Ack_in & SkipM)==SkipM)  'wait for pasm to read move or soft reset or skip
       Ack_in := Ack_in & !movRDY                                'Ack into pasm that spin sees the move was read

       if ((skips[buff_tail] & SkipBit) <> 0)      'skipbit = 100_0000_0000_0000_0000
             sAxis := skips[buff_tail] & $ff
             PinS := (skips[buff_tail] ror 8) & $ff
             Transition := (skips[buff_tail]ror 16) & 1  'Transition =  1_0000_0000_0000_0000   "low to high" or "high to low"><><
             ZeroAxis   := (skips[buff_tail]ror 17) & 1  'ZeroAxis   = 10_0000_0000_0000_0000
             'sAxis := 0
             'PinS := 16
             'Transition := 0 '0 means when pin goes low, 1 means skip when pin goes high
             ZeroAxis := 1   'not sure I want to zero axis in all cases??
             SkipMove(sAxis,PinS,Transition,ZeroAxis)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI SkipMove(sAxis,SkipPin,transition,ZeroAxis) | first
        first := true
        'term.str(string("in Skip",13,10))
        repeat while ((Ack_out & ACTmov)==ACTmov) or ((Ack_out & ACTdec)==ACTdec)  'do while moving

              if ((Transition == 1) AND (PINR(SkipPin) <> 0)) OR ((Transition == 0) AND (PINR(SkipPin) == 0))     'pin goes high
                  if first
                     if (Transition == 1)
                        term.str(string("Limit signal already low",13,10))
                     else
                        term.str(string("Limit signal already High",13,10))
                  else
                        term.str(string("Limit triggered",13,10))

                  Ack_in := Ack_in | SkipM    'set "skip rest of move" bit to PASM
                  waitms(50)
                  AbsX := Xpos
                  AbsY := Ypos
                  AbsZ := Zpos
                  AbsA := Apos
                  Ack_in := Ack_in & !SkipM   'reset "skip rest of move bit"
                  if (ZeroAxis==1)
                    if  ((sAxis & Bit0) <>0)
                         Xmove := 0
                         Ack_in := Ack_in | Zero_X    'set "Zero_X" bit
                         repeat while (Xpos <>0)
                         AbsX := 0
                         Ack_in := Ack_in & !Zero_X   'reset "Zero_X" bit

                    if  ((sAxis & Bit1) <>0)
                         Ymove := 0
                         Ack_in := Ack_in | Zero_Y    'set "Zero_Y" bit
                         repeat while (Ypos <>0)
                         AbsY := 0
                         Ack_in := Ack_in & !Zero_Y   'reset "Zero_Y" bit

                    if  ((sAxis & Bit2) <>0)
                         Zmove := 0
                         Ack_in := Ack_in | Zero_Z    'set "Zero_Z" bit
                         repeat while (Zpos <>0)
                         AbsZ := 0
                         Ack_in := Ack_in & !Zero_Z   'reset "Zero_Z" bit

                    if  ((sAxis & Bit3) <>0)
                         Amove := 0
                         Ack_in := Ack_in | Zero_A    'set "Zero_A" bit
                         repeat while (Apos <>0)
                         AbsA := 0
                         Ack_in := Ack_in & !Zero_A   'reset "Zero_A" bit

          first := false
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PUB Parse(inPTR)  | base,index,param,pval,sPTR,id1,id2
    repeat while (BYTE[inPTR] <> 0)
      case BYTE[inPTR]

        "$" : BYTE[inPTR]:=0   'null the first string char
              case BYTE[inPTR+1]

                "$"  :repeat index from 0 to 33    ' "$$" -> Send out all 33 Grbl parameters
                       term.fstr1(string("$%d="),Pnum[index])
                       term.dpdec(ParGrbl[Pnum[index]],ParFmt[Pnum[index]]) 'some need decimal points
                       term.str(string(13,10))
                     term.str(string("ok",13,10))
                     'Xscale := ParGrbl[100]
                     'Yscale := ParGrbl[101]
                     'Zscale := ParGrbl[102]
                     'Ascale := ParGrbl[103]

                "#"     : term.str(string("[G54:0.000,0.000,0.000]",13,10))
                          term.str(string("[G55:0.000,0.000,0.000]",13,10))
                          term.str(string("[G56:0.000,0.000,0.000]",13,10))
                          term.str(string("[G57:0.000,0.000,0.000]",13,10))
                          term.str(string("[G58:0.000,0.000,0.000]",13,10))
                          term.str(string("[G59:0.000,0.000,0.000]",13,10))
                          term.str(string("[G28:0.000,0.000,0.000]",13,10))
                          term.str(string("[G30:0.000,0.000,0.000]",13,10))
                          term.str(string("[G92:0.000,0.000,0.000]",13,10))
                          term.str(string("[TLO:0.000]",13,10))
                          term.str(string("[PRB:0.000,0.000,0.000:0]",13,10))
                          term.str(string("ok",13,10))

                "g"     : if ABS_G90
                                term.fstr2(string("[GC:G0%d G54 G17 G21 G90 G94 M5 M9 T0 F%d S0]",13,10,"ok",13,10),MoveType,global_feed)
                          else
                                term.fstr2(string("[GC:G0%d G54 G17 G21 G91 G94 M5 M9 T0 F%d S0]",13,10,"ok",13,10),MoveType,global_feed)

                "0".."9":  param := DecIn(1,inPTR) 'read in parameter, ie "$101=567.456"
                           case BYTE[inPTR]
                              "=" : case ParFmt[param]
                                       0 : ParGrbl[param] := DecIn(1,inPTR)
                                       3 : ParGrbl[param] := DecIn(2,inPTR)
                                    term.str(string("ok",13,10))

                "h"  :  Homing := true
                        HomingStage := 0
                       ' term.str(string("Homing",13,10))

        "g" :  gvalue := DecIn(1,inPTR)  'G code command
              'term.fstr1(string("G type: %d \r"),gvalue[buff_head])
              new_move := 1

              case gvalue
                0 : gMtype[buff_head] := 0
                1 : gMtype[buff_head] := 1
                2 : gMtype[buff_head] := 2
                3 : gMtype[buff_head] := 3
                4 : gMtype[buff_head] := 4
                17: gPlane[buff_head] := 17
                18: gPlane[buff_head] := 18
                19: gPlane[buff_head] := 19
                20: gUnits[buff_head] := 20
                21: gUnits[buff_head] := 21
                90: gAbs[buff_head]   := 90
                91: gAbs[buff_head]   := 91
                92: gMtype[buff_head] := 92
                382: 'term.str(string("G38.2",13,10))'set skip bit,axis,switch input,low to high or high to low transition,messaging
                     skips[buff_head] := skips[buff_head] | SkipBit  'set skip move type bit
                     skips[buff_head] := skips[buff_head] & !TransBit  'set transition for high->low bit
                383: 'term.str(string("G38.3",13,10))
                     skips[buff_head] := skips[buff_head] | SkipBit  'set skip move type bit
                     skips[buff_head] := skips[buff_head] & !TransBit  'set transition (low to high, high to low) type bit
                384: 'term.str(string("G38.4",13,10))
                     skips[buff_head] := skips[buff_head] | SkipBit  'set skip move type bit
                     skips[buff_head] := skips[buff_head] | TransBit  'set transition for low->high type bit
                385: 'term.str(string("G38.5",13,10))
                     skips[buff_head] := skips[buff_head] | SkipBit  'set skip move type bit
                     skips[buff_head] := skips[buff_head] | TransBit  'set transition (low to high, high to low) type bit
               other: term.str(string("Unrecognised G code",13,10))

              case gvalue
               0..4   :  inputs[buff_head] := inputs[Buff_head] | gMin    'set modal move type change bit
               9      :  inputs[buff_head] := inputs[Buff_head] | ExStopb 'set exact stop G9 bit
               17..19 :  inputs[buff_head] := inputs[Buff_head] | gPin    'set modal plane change
               20..21 :  inputs[buff_head] := inputs[Buff_head] | Inin    'set inch/metric change bit
               90..91 :  inputs[buff_head] := inputs[Buff_head] | ABSin   'set inc/abs change bit

        "m" :  mvalue := DecIn(1,inPTR)  'G code command
              'term.fstr1(string("G type: %d \r"),gvalue[buff_head])
              new_move := 1

              case mvalue
                300 : skips[buff_head] := skips[buff_head] |( xHiLmtPin rol 8)
                301 : skips[buff_head] := skips[buff_head] |( xLoLmtPin rol 8)
                302 : skips[buff_head] := skips[buff_head] |( yHiLmtPin rol 8)
                303 : skips[buff_head] := skips[buff_head] |( yLoLmtPin rol 8)
                304 : skips[buff_head] := skips[buff_head] |( zHiLmtPin rol 8)
                305 : skips[buff_head] := skips[buff_head] |( zLoLmtPin rol 8)
                306 : skips[buff_head] := skips[buff_head] |( aHiLmtPin rol 8)
                307 : skips[buff_head] := skips[buff_head] |( aLoLmtPin rol 8)
                308 : skips[buff_head] := skips[buff_head] |( bHiLmtPin rol 8)
                309 : skips[buff_head] := skips[buff_head] |( bLoLmtPin rol 8)
                310 : skips[buff_head] := skips[buff_head] |( Probe1Pin rol 8)
                311 : skips[buff_head] := skips[buff_head] |( Probe2Pin rol 8)

       ' "e" :  evalue := DecIn(2,inPTR)  'G code command
              'term.fstr1(string("G type: %d \r"),gvalue[buff_head])

        "p" :  pvalue[buff_head] := DecIn(2,inPTR)   'time delay
              inputs[buff_head] := inputs[Buff_head] | Pin
              'term.fstr1(string("Feed: %d \r"),pvalue[buff_head])
              new_move := 1

        "f" :  fvalue[buff_head] := DecIn(3,inPTR)   'feed rate
              inputs[buff_head] := inputs[Buff_head] | Fin
              'term.fstr1(string("Feed: %d \r"),fvalue[buff_head])
              new_move := 1

        "x" :  xvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Xin
              skips[buff_head] := skips[buff_head] | Bit0
              'term.fstr1(string("X move: %d \r"),xvalue[buff_head])
              new_move := 1

        "y" :  yvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Yin
              skips[buff_head] := skips[buff_head] | Bit1
              'term.fstr1(string("Y move: %d \r"),yvalue[buff_head])
              new_move := 1

        "z" :  zvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Zin
              skips[buff_head] := skips[buff_head] | Bit2
              'term.fstr1(string("Z move: %d \r"),zvalue[buff_head])
              new_move := 1

        "a","e" :  avalue[buff_head] := DecIn(2,inPTR)     'reading extruder motion into A axis here....!!!!
                   inputs[buff_head] := inputs[Buff_head] | Ain
                   skips[buff_head] := skips[buff_head] | Bit3
                  'term.fstr1(string("A move: %d \r"),avalue[buff_head])
                   new_move := 1

        "i" :  ivalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Iin
              'term.fstr1(string("I value: %d \r"),ivalue[buff_head])
              new_move := 1

        "j" :  jvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Jin
              'term.fstr1(string("J value: %d \r"),jvalue[buff_head])
              new_move := 1

        "k" :  kvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Kin
              'term.fstr1(string("K value: %d \r"),kvalue[buff_head])
              new_move := 1

        "r" :  rvalue[buff_head] := DecIn(2,inPTR)
              inputs[buff_head] := inputs[Buff_head] | Rin
              'term.fstr1(string("R value: %d \r"),rvalue[buff_head])
              new_move := 1



        "s" :  svalue[buff_head] := DecIn(2,inPTR)   'spindle speed
              inputs[buff_head] := inputs[Buff_head] | Sin
              'term.fstr1(string("Spindle speed: %d \r"),svalue[buff_head])
              new_move := 1

        "t" :  tvalue[buff_head] := DecIn(2,inPTR)   'tool number
              inputs[buff_head] := inputs[Buff_head] | Tin
              'term.fstr1(string("Tool number: %d \r"),tvalue[buff_head])
              new_move := 1

        ">" :  base,index := 0,1
              BYTE[inPTR+base] := BYTE[inPTR+index]
              repeat until BYTE[inPTR+index] == 0
                base++
                index++
                BYTE[inPTR+base] := BYTE[inPTR+index]

        ";" : BYTE[inPTR] := 0  'don't process anything after a semicolon

    if (new_move == 1)
         'term.fstr1(string("buffer head=%d"),buff_head)
         buff_head := buff_head + 1
           if buff_head > 99
              buff_head := 0
         Buffered++
         new_move := 0
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PUB  Home() | index,testnum


     if Buffered < 1
      case homingStage

       0:   MDI(string("G38.2G1G91X-600f500M300"))
            MDI(string("G38.4G1G91X10f40M300"))
            MDI(string("G38.2G1G91X-10f20M300"))
            MDI(string("G92X0.0"))
            HomingStage := 1


       1:   MDI(string("G38.2G1G91Y-600f500M301"))
            MDI(string("G38.4G1G91Y10f40M301"))
            MDI(string("G38.2G1G91Y-10f20M301"))
            MDI(string("G92Y0.0"))
            HomingStage := 2

       2:   MDI(string("G38.2G1G91Z-600f500M302"))
            MDI(string("G38.4G1G91Z10f40M302"))
            MDI(string("G38.2G1G91Z-10f20M302"))
            MDI(string("G92Z0.0"))
            MDI(string("G4P2.0"))
            MDI(string("G90G1X100Y100Z100F2000"))
            Homing := false
            Homed := true

PUB  AutoCycle() | v1,v2,v3,v4

        v1 := -3200
        v2 :=  3200
       'term.str(EmbedNum(string("G1G91X%f500M300"),xMotion,v2,v3,v4))
        MDI(EmbedNum(string("G1G91X%f500M300"),v1,v2,v3,v4))          'these moves get loaded into the move buffer
        MDI(EmbedNum(string("G1G91Y%f500M300"),v1,v2,v3,v4))
        MDI(string("G4P2.5")) 'dwell
        MDI(EmbedNum(string("G1G91X%Y%f500M300"),v1,v2,v3,v4))
        MDI(EmbedNum(string("G1G91X%Y%f500M300"),v2,v1,v3,v4))

PUB EmbedNum(inPTR,Val1,Val2,Val3,Val4) : outPTR | InIndex,OutIndex ,ScrPTR1,valCnt   'inserts "Val" when it sees a "%"
                                                                                      'up to 4 times
         ValCnt := 0
         InIndex := 0
         OutIndex := 0
         repeat while byte[inPTR+InIndex] <>0

          if byte[inPTR+InIndex] == "%"
            case ValCnt
              0 : ScrPTR1 := fmt.dpdec(Val1,3)      'dpdec() is in jm_nstr
              1 : ScrPTR1 := fmt.dpdec(Val2,3)
              2 : ScrPTR1 := fmt.dpdec(Val3,3)
              3 : ScrPTR1 := fmt.dpdec(Val4,3)
            ValCnt++
            repeat while (byte[ScrPTR1] <> 0)
               Byte[@Tempstr4+OutIndex]:= byte[ScrPTR1] 'insert number into string
               OutIndex++
               ScrPTR1++
            InIndex++
          else
            Byte[@Tempstr4+OutIndex] := byte[inPTR+InIndex]
            InIndex++
            OutIndex++
         Byte[@Tempstr4+OutIndex] := byte[inPTR+InIndex]
         outPTR := @Tempstr4


PUB MDI(inPTR)| InIndex,OutIndex, InChar      'MDI manual data input
    InIndex := 0
    OutIndex := 0
    InChar := BYTE[inPTR+InIndex]
    repeat while ((InChar<>0) and (InChar<> ";") and (InChar<>10) and (InChar<>13) and (InChar<>$F8)) 'Null, semicolon,<CR>,<LF>or<EOF>
      case InChar    'BYTE[inPTR+InIndex]
          "-"      :  BYTE[@tempstr+OutIndex] := InChar
          "."      :  BYTE[@tempstr+OutIndex] := InChar
          "0".."9" :  BYTE[@tempstr+OutIndex] := InChar
          "A".."Z" :  BYTE[@tempstr+OutIndex] := InChar + 32
          "a".."z" :  BYTE[@tempstr+OutIndex] := InChar
       other       :  OutIndex--    'throw away all others
      InIndex++
      OutIndex++
      InChar := BYTE[inPTR+InIndex]

    BYTE[@tempstr+OutIndex] :=0             'null teriminator for string
    term.str(@tempstr)
    term.str(string(13,10))
    Parse(@tempstr) 'Parse destroys string it parses


PUB DecIn(type,inPTR) : value | index,isign,char,done,base,dpcnt     'Decimal Input
{ Characters other than numbers, minus, are ignored.}
  value,done,base,dpcnt := 0,0,0,0
  isign,index := 1,1
  repeat
    Char := BYTE[inPTR+index]
    case Char
      "-"     : isign := -1
                index++

      "."     : dpcnt++
                index++

      "0".."9": value *= 10
                value += Char - "0"
                index++
                if (dpcnt > 0)
                    dpcnt++
      other: done := 1
  until done == 1
  if index==1
    error := 1 'set error for no numbers found
  else
    if (type == 2) 'strip decimal point and multiply by 1000 for axis moves
       case dpcnt
         0 : value *=1000
         1 : value *=1000
         2 : value *=100
         3 : value *=10
         4 : value *=1
         5 : value /=10
         6 : value /=100
         7 : value /=1000

    if (type == 3) 'strip decimal point, multiply by 10, return integer part for feed rate
       case dpcnt  'so if input feed was 100.45mm/min, it will use 1004 which is 100.4
         0 : value *=10
         1 : value *=10
         2 : value /=1
         3 : value /=10
         4 : value /=100
         5 : value /=1000
'''''shift string left''''''''''''''
  BYTE[inPTR+base] := BYTE[inPTR+index]
  repeat until BYTE[inPTR+index] == 0
   base++
   index++
   BYTE[inPTR+base] := BYTE[inPTR+index]
''''''''''''''''''''''''''''''''''''''
  value *= isign

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI RealTimeStatus()| rts1,rts2,rts3


      if ((Ack_Out & 6) == 0)         'active move and active decel bits from PASM
         GrblState := 0 'Idle
      elseif ((Ack_In & Bit1) == 0)   'feed hold bit
         GrblState := 1 'Run
      else
         GrblState := 2 'Hold:0

      case GrblState  ' "Hold:0"

                     '0-Idle,1-Run,2-Hold:0,3-Hold:1,4-Jog,5-Alarm,6-Door:0,7-Door:1,
                     '8-Door:2,9-Door:3,10-Check,11-Home,12-Sleep

        0:
         term.str(string("<Idle|"))
        1:
         term.str(string("<Run|"))
        2:
         term.str(string("<Hold:0|"))
        3:
         term.str(string("<Hold:1|"))
        4:
         term.str(string("<Jog|"))
        5:
         term.str(string("<Alarm|"))
        6:
         term.str(string("<Door:0|"))
        7:
         term.str(string("<Door:1|"))
        8:
         term.str(string("<Door:2|"))
        9:
         term.str(string("<Door:3|"))
        10:
         term.str(string("<Check|"))
        11:
         term.str(string("<Home|"))
        12:
         term.str(string("<Sleep|"))


      term.str(string("MPos:"))
      term.dpdec(xpos,3)
      term.tx(",")
      term.dpdec(ypos,3)
      term.tx(",")
      term.dpdec(zpos,3)
      'term.tx(",")       'output A position if gcode sender can tolerate it
      'term.dpdec(apos,3)


                'Bit0-State,Bit1-work offsets,Bit2-buffer status,Bit3-feed/speed,
                'Bit4-feed overides,Bit5-Accessories,Bit6-input pin states

      if ((UpdateFlags & Bit0) <> 0)
          UpdateFlags := UpdateFlags & !Bit0   'turn off update flag

      if ((UpdateFlags & Bit1) <> 0)
          UpdateFlags := UpdateFlags & !Bit1   'turn off update flag

      if ((UpdateFlags & Bit2) <> 0)
          UpdateFlags := UpdateFlags & !Bit2   'turn off update flag

      if ((UpdateFlags & Bit3) <> 0)
          term.str(string("|FS:"))
          'term.dpdec(global_feed,1)            '|FS:0,0 -> feed and spiddle rpm
          term.dpdec((Global_Feed*Frof)/100,1)            '|FS:0,0 -> feed and spiddle rpm
          term.str(string(",0"))
          UpdateFlags := UpdateFlags & !Bit3   'turn off update flag

      if ((UpdateFlags & Bit4) <> 0)           'feed overides
          term.str(string("|Ov:"))
          term.dpdec(FroF,0)
          term.str(string(","))
          term.dpdec(FroR,0)
          term.str(string(","))
          term.dpdec(FroS,0)
          UpdateFlags := UpdateFlags & !Bit4     'turn off update flag

      if ((UpdateFlags & Bit5) <> 0)
          term.str(string("|A:SFM"))           'Accesory state
          UpdateFlags := UpdateFlags & !Bit5     'turn off update flag

      if ((UpdateFlags & Bit6) <> 0)
          term.str(string("|Pn:XYZPDHRS"))     'Pin states
          UpdateFlags := UpdateFlags & !Bit6     'turn off update flag
      term.str(string(">",13,10))

      UpdateFlags := UpdateFlags | Bit3 'always output feeds
      UpdateCnt := UpdateCnt +1
      if UpdateCnt > 11
         UpdateCnt := 0
      case UpdateCnt
             0 : UpdateFlags := UpdateFlags | Bit4
             4 : UpdateFlags := UpdateFlags | Bit5
             8 : UpdateFlags := UpdateFlags | Bit6
             9 : term.fstr2(string("buffer head: %d , Buffer Tail:%d",13,10),buff_head,buff_tail)



                                                   '|FS:0,0 -> feed and spiddle rpm
                                                   '|Pn:XYZPDHRS x,y,z limits,Probe,Door,Hold,Reset,Start
                                                   '|Bf:15,128 ->planer and buffer remaining
                                                   '|Ov:100,100,100 -> overides for feed, rapids, spindle
                                                   '|WCO:0.000,0.000,0.000 -> work coordinate offsets
                                                   '|A:(SorC)FM -> S cw enable spindle, C ccw enable spindle
                                                     'F flood coolant on, M mist coolant on


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''''''''''''Main PASM pulse2 program'''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

DAT           ORG     0

pulse2        MOV     WritePTR,ptra
              MOV     ReadPTR,ptra
              ADD     ReadPTR,#36
              MOV     AckPTR,ptra
              ADD     AckPTR,#60


              DRVL   ##(256+128+64+BasePin)'basepin + 7 additional
              'DRVL   ##%00111_000000 'pins 0 to 7 low... pin0 with 7 additional
              'DRVL   ##%00111_001000 pins 8 to 15 low... pin8 with 7 additional

              'DRVL   pXstep
              'DRVL   pXdir
              'DRVL   pYstep
              'DRVL   pYdir
              'DRVL   pZstep
              'DRVL   pZdir
              'DRVL   pAstep
              'DRVL   pAdir

''''''''''''''LUT load routine'''''''''''''''''''''''''''''''''''''''''''''''''''''
              RDLONG xtraptr,ptra  'read in xpos(pointed to by ptra), which has hub address of lutcall in it
              SETQ2 #$1EF
              RDLONG pulse2,xtraptr  'pulse2 is address zero, but use it for LUT address zero also, not sure how else to do this?
                                      'using setQ2 makes these RDLONG's go into LUT area
''''''''''''''LUT load routine end'''''''''''''''''''''''''''''''''''''''''''''''''
              GETCT   tv8             'get initial Clock count
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''top of main loop''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

loop          ADDCT1  tv8,pDelay      'update CT1 target pDelay is changed for different feed rate overrides.
              WAITCT1                 'wait for CT to pass CT1 target
              add pLoopcnt1,#1        'increment main counter
              getct time1

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''check for loopcnt=blocktime'''''''''''''''''''''''''''''''''''''''''''''''''''''''
              cmp pLoopcnt1,pblocktime wz 'if they are equal, Z flag is set
     if_z     CALL #\lcEQbt           'pLoopcnt1==blocktime, check for next move, read in if there is one
                                       'SumX only gets modified here and when loopcnt1==AccTC'
''''''''''''''lower ACKout if ACKin is low''''''''''''''''''''''''''''''''''''''''''''''''''''''
              testb  pAck_in,#0 wz        'when pAck_in bit0 goes low, lower pAck_out bit0
     if_nz    bitL   pAck_out,#0          'acknowledge acknowledge reading new move

''''''''''''''write to hub''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
              SetQ #8                  'output to hub every loop
              wrlong pXpos,WritePTR    'Xpos,Ypos,Zpos,Apos,Xvel,Yvel,Zvel,Avel,Ack_out

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''check looptime vs AccTC'''3 possiable results'''''''''''''''''''''''''''''''''''''
              CMP pLoopcnt1,pAccTC wcz
if_nz_and_c   CALL #\lcLTtc              'If in Acc/Dec part of move calculate the'''''
                                         'triangular area part of velocity trapazoid'''
if_z          CALL #\lcEQtc              'looptime==AccTC''''''''''''''''''''''''''''''

if_nz_and_nc  CALL #\lcGTtc              'If in Constant velocity part of move calculate'
                                         'the rectangular area part of velocity trapazoid'

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Scale         CALL #\ScaleLUT  'ScalePTR
Pulses        CALL #\PulsesLUT 'PulsesPTR

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
''''''''''''''''''do extra stuff like feed override, soft reset, feed pause, loop timing''''''''
''''''''''''''''''before jumping back to the top''''''''''''''''''''''''''''''''''''''''''''''''
CheckIn       rdlong pAck_in,AckPTR

              testb pAck_in,#1   wz    'Check for feed hold.. loop untill feed hold bit clears
       if_z   sub pLoopCnt1,#1

              testb pAck_in,#2   wz    'Check for Soft Reset... this will clear the buffers if it runs a few loops...
       if_z   call #\SoftRsLUT         'this will clear the buffers if it runs a few loops...

              testb pAck_in,#3   wz    'Check for Skip... this will skip the remainder of the move...
       if_z   call #\SoftRsLUT         'this will clear the buffers if it runs a few loops...

              testb pAck_in,#12   wz   'Check for Zero_X... zero pXpos
       if_z   call #\zipX              'Zero pXpos and others
              testb pAck_in,#13   wz   'Check for Zero_Y... zero pYpos
       if_z   call #\zipY              'Zero pXpos and others
              testb pAck_in,#14   wz   'Check for Zero_Z... zero pZpos
       if_z   call #\zipZ              'Zero pXpos and others
              testb pAck_in,#15   wz   'Check for Zero_A... zero pApos
       if_z   call #\zipA              'Zero pXpos and others


              add AckPTR,#76       ''This is getting the feed rate override that increases/decreases the looptime delay                ''
              rdlong pDelay,AckPTR ''
              sub AckPTR,#76       ''

              getct time2
              sub time2,time1
              mov et,time2
              cmp maxET,et wc    'if they are equal, Z flag is set.  If cntr1 less than 20_000 C flag is set
      If_c    mov maxet,et
             ' mov pZpos,et       'testing, remove later send looptine over in zvel var temp
              'mov pZpos,Yscaled  'testing... remove later
              'mov pZpos,pApos    'testing...

              getct time1
              nop
              JMP     #loop          'loop to the WAITCT1

'''''''''''''END MAIN PASM PULSE PROGRAM'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

pXpos      long 0           'Axis positions
pYpos      long 0
pZpos      long 0
pApos      long 0
pXvel      long 0           'Axis velocities
pYvel      long 0
pZvel      long 0
pAvel      long 0
pAck_out   long 0           'Bit0->Acknowledge flag, Bit1->move active, Bit2->deceleration active

pXmove     long 0           'move distance
pYmove     long 0
pZmove     long 0
pAmove     long 0
pBlocktime long 100_000     'move time
pAccTC     long 0           'time constant
pAck_in    long 0           'Bit0->new move, Bit1->pause motion, Bit2->soft reset
pAccDisX   long 0
pAccDisY   long 0
pAccDisZ   long 0
pAccDisA   long 0
pSqTC      long 0
pExStop    long 0
pSign      long 0
pXscale    long 0
pYscale    long 0
pZscale    long 0
pAscale    long 0
pStT       long 0
pEndT      long 0
pDisT      long 0
pOffsetX   long 0
pOffsetY   long 0
pAccDisT   long 0
pRad       long 0

tv1        long 0
tv2        long 0
tv3        long 0
tv8        long 0

pDecDisX   long 0
pDecDisY   long 0
pDecDisZ   long 0
pDecDisA   long 0
pDecDisT   long 0
pBlokDisX  long 0
pBlokDisY  long 0
pBlokDisZ  long 0
pBlokDisA  long 0
pBlokDisT  long 0
pSumX      long 0
pSumY      long 0
pSumZ      long 0
pSumA      long 0
pSumT      long 0
pSigno     long 0
pRado      long 0
pStTo      long 0
pEndTo     long 0
pOffsetXo  long 0
pOffsetYo  long 0
pXveld     long 0
pYveld     long 0
pZveld     long 0
pAveld     long 0

pXprog     long 0 'new Xmove acceleration distance progress
pXprogd    long 0 'prior Xmove deceleration distance progress
pYprog     long 0
pYprogd    long 0
pZprog     long 0
pZprogd    long 0
pAprog     long 0
pAprogd    long 0
pTprog     long 0 'progress theta accel
pTprogd    long 0 'progress theta decel

neg1       long 0

AlphaXa    long 0
AlphaYa    long 0
AlphaXd    long 0
AlphaYd    long 0

Xpulse     long 0
Ypulse     long 0
Zpulse     long 0
Apulse     long 0

Xscaled    long 0
Yscaled    long 0
Zscaled    long 0
Ascaled    long 0

ScaleDiv   long 1_000_000

BasePin    long 0
Spin       long 0     'Step pin
Dpin       long 0     'Direction pin
DirBits    long %0000 'set bit to change step direction  Bit0 is X direction, Bit2 is Y direction, etc.
DirBit     long %0
DirSkp     long 0    'mask used in pulsesLUT, skips 3rd and 4th instruction for normal direction, or 1st and 2nd for reverse dir

pLoopcnt1   long 0
'pLoopcnt2   long 0
time1       long 0
time2       long 0
et          long 0
maxET       long 0
pDelay      long 2_000    'this is 2000 clock ticks at the 200Mhz system speed...-> 1/100_000Sec
                          'make this bigger for feed rate override.
ReadPTR     long 0
WritePTR    long 0
AckPTR      long 0
OddPTR      long 0
xtraptr     long $200
xp2         long 5

'Part1PTR    long $200   'Triangle area calculation of velocity for position; loopcnt 0->AccTC (20,000)
'Part2PTR    long $201   'Transition from acceleration to constant velocity part of velocity trapizoid: loopcnt=AccTC
'Part3PTR    long $202   'Rectangular area calculation of velocity for position;
'Part4PTR    long $203   'Current move shifted to old move, check for new moves,
'XferPTR     long $204    'Used by NextMov routine to move variables around and zero some
'ScalePTR    long $205    '
'PulsesPTR   long $206
'SoftRsPTR   long $207


DAT           ORG $200         'load some of my program into LUT to  open up space in the main cog
          '                    'org $200 because jumps are absolute
LutCall
              'JMP  #\lcLTtc    'if looptime < TimeConstant then do acc/dec area calculation
              'JMP  #\lcEQtc    'if looptime = TimeConstant
              'JMP  #\lcGTtc    'if looptime > TimeConstant then do constant velocity area calculation
              'JMP  #\lcEQbt    'if looptime = Blocktime, shift current to old, sum values, and read in next move
              'JMP  #\Xfer2
              'JMP  #\ScaleLUT
              'JMP  #\PulsesLUT
              'JMP  #\SoftRsLUT

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''LUT FUNCTION CALLS''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

''''''''''''''looptime LESS THAN timeconstant acc/dec Call'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
lcLTtc        QMUL ploopcnt1,ploopcnt1  'square loopcnt1 can't be bigger than 65536, same as AccTC
              GETQX tv1                 'get result looptime squared
              GETQY tv2                 'not sure if I need to read this, but I don't use it...

              ABS  tv2,pAccDisX
              QMUL tv2,tv1            'ABS pAccelerationDistanceX
              ABS  tv2,pAccDisY
              QMUL tv2,tv1
              ABS  tv2,pAccDisZ
              QMUL tv2,tv1
              ABS  tv2,pAccDisA
              QMUL tv2,tv1
              MOV  tv2,pAccDisT   'don't ABS this one! Ugh!!!
              QMUL tv2,tv1

              REP #4,#5
              GETQX tv2                 'get result from x product axis
              GETQY tv3                 'acc distance is ratio ((loopcnt^2)/(AccTC^2)) times "Acc total distance"
              SETQ tv3                  'this has the high 32 bits
              QDIV tv2,pSqTC            'tv2 is low 32 bits, divided by (TC*TC)

              GETQX pXprog
              GETQX pYprog
              GETQX pZprog
              GETQX pAprog
              GETQX pTprog

              SKIPF pSign
              Neg  pXprog               'then make pXprog negative also
              Neg  pYprog               'then make pXprog negative also
              Neg  pZprog               'then make pXprog negative also
              Neg  pAprog
              nop                       'theta sign bit

              ''''''''''''''''''''decel''''''''''''''''
              MOV   tv1,pAccTC
              SUB   tv1,pLoopCnt1       'AccTC-LoopCnt1 for decel!!!
              QMUL  tv1,tv1             'square loopcnt1
              GETQX tv1                 'get result looptime squared
              GETQY tv2                 'tv1 result needs to be less than 32 bits

              ABS  tv2,pDecDisX
              QMUL tv2,tv1              'ABS pDecelDistanceX
              ABS  tv2,pDecDisY
              QMUL tv2,tv1
              ABS  tv2,pDecDisZ
              QMUL tv2,tv1
              ABS  tv2,pDecDisA
              QMUL tv2,tv1
              MOV  tv2,pDecDisT          'don't ABS this one... ugh...
              QMUL tv2,tv1

              REP #4,#5
              GETQX tv2                 'get result from x product axis
              GETQY tv3                 'acc distance is ratio ((loopcnt^2)/(AccTC^2)) times "Acc total distance"
              SETQ  tv3                 'this has the high 32 bits
              QDIV  tv2,pSqTC           'tv2 is low 32 bits, divided by (TC*TC)

              GETQX pXprogd
              ABS tv1,pDecDisX
              sub tv1,pXprogd
              mov pXprogd,tv1
              GETQX pYprogd
              ABS tv1,pDecDisY
              sub tv1,pYprogd
              mov pYprogd,tv1
              GETQX pZprogd
              ABS tv1,pDecDisZ
              sub tv1,pZprogd
              mov pZprogd,tv1
              GETQX pAprogd
              ABS tv1,pDecDisA
              sub tv1,pAprogd
              mov pAprogd,tv1
              GETQX pTprogd

              mov tv1,pDecDisT
              sub tv1,pTprogd
              mov pTprogd,tv1

              Skipf pSigno            'sign of old move
              Neg pXprogd
              Neg pYprogd
              Neg pZprogd
              Neg pAprogd
              nop                     'nop here for theta sign bit so we don't skip the next ADD line

              ''''''''''''''''''''''''''''''''''''''''''''''''''''''
              add pTprog,pStT         'convert from degrees to 32 bit???
              SHL pTprog,#4           'take out multi turn part
              QROTATE pRad,pTprog
              GETQX AlphaXa
              GETQY AlphaYa

              mov tv1,pEndTo          'convert from degrees to 32 bit???
              sub tv1,pDecDisT
              add tv1,pTprogd
              SHL tv1,#4              'take out multiturn part
              QROTATE pRado,tv1
              GETQX AlphaXd
              GETQY AlphaYd

              testb pSign, #4 wz     'make negative for G02 CW move
              NegNZ  AlphaXa

              testb pSigno, #4 wz     'make negative for G02 CW move
              NegNZ  AlphaXd

              ''''''''''''''''''''''''''''''''''''''''''''''''''''''
              mov  pXpos,pSumX
              mov  pYpos,pSumY
              mov  pZpos,pSumZ
              mov  pApos,pSumA
              adds pXpos,pXprog  'add accel distance from current move
              adds pYpos,pYprog
              adds pZpos,pZprog
              adds pApos,pAprog

              adds pXpos,pXprogd 'add decel distance from prior move

              adds pXpos,AlphaXa
              subs pXpos,pOffsetX

              adds pXpos,AlphaXd
              subs pXpos,pOffsetXo

              adds pYpos,pYprogd

              adds pYpos,AlphaYa
              subs pYpos,pOffsetY

              adds pYpos,AlphaYd
              subs pYpos,pOffsetYo

              adds pZpos,pZprogd
              adds pApos,pAprogd
              ret  wcz

''''''''''''''ltEQtc Call'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
lcEQtc        adds pSumX,pAccDisX  'adds in current moves acceleration distance to pSumX
              adds pSumX,pDecDisX  'should add up to old Xmove exactly...

              adds pSumY,pAccDisY
              adds pSumY,pDecDisY  'good...

              adds pSumZ,pAccDisZ
              adds pSumZ,pDecDisZ  'good...

              adds pSumA,pAccDisA
              adds pSumA,pDecDisA  'good...

              adds pSumX,AlphaXd   'depends on plane! G17
              adds pSumY,AlphaYd

              subs pSumX,pOffsetXo  'depends on plane! G17
              subs pSumY,pOffsetYo

              mov  AlphaXd,#0
              mov  AlphaYd,#0

              mov  pXpos,pSumX
              mov  pYpos,pSumY
              mov  pZpos,pSumZ
              mov  pApos,pSumA

              bitL pAck_out,#2             'clear the "deceleration active" bit
              ret  wcz

''''''''''''''ltGTtc Call''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
lcGTtc        Mov tv1,pLoopCnt1         'Do this : SumX + Xmove*(loopcnt1-AccTC)/bt
              Sub tv1,pAccTC            'looptime is bigger than AccTC once past acc part

              ABS  tv2,pXmove
              QMUL tv2,tv1             'tv1 is pLoopCnt1 - AccTC
              ABS  tv2,pYmove
              QMUL tv2,tv1
              ABS  tv2,pZmove
              QMUL tv2,tv1
              ABS  tv2,pAmove
              QMUL tv2,tv1
              MOV  tv2,pDisT            'don't ABS this one...
              QMUL tv2,tv1

              rep #4,#5                'load up cordic pipeline
              GETQX tv1                'get result from x product axis
              GETQY tv2
              SETQ  tv2                'start
              QDIV tv1,pBlocktime      'load cordic pipeline with 4 divisions

              GETQX pBlokDisX
              GETQX pBlokDisY
              GETQX pBlokDisZ
              GETQX pBlokDisA
              GETQX pBlokDisT

              SKIPF pSign
              Neg  pBlokDisX            'then make pBlokDisX negative also
              Neg  pBlokDisY
              Neg  pBlokDisZ
              Neg  pBlokDisA
              nop

              {'testb pXmove, #31 wz   'instead of SKIPF this is the other way to correct for the sign  '
              'NegZ  pBlokDisX        'not sure what I like better
              'testb pYmove, #31 wz
              'NegZ  pBlokDisY
              'testb pZmove, #31 wz
              'NegZ  pBlokDisZ
              'testb pAmove, #31 wz
              'NegZ  pBlokDisA       }

              add pBlokDisT,pStT
              add pBlokDisT,pAccDisT  '3/24
              SHL pBlokDisT,#4        'take out multiturn part
              QROTATE pRad,pBlokDisT
              GETQX AlphaXa            'negate if negative move
              GETQY AlphaYa

              testb pSign, #4 wz       'make negative for G02 CW move
              NegNZ  AlphaXa

              MOV pXpos,pBlokDisX
              MOV pYpos,pBlokDisY
              MOV pZpos,pBlokDisZ
              MOV pApos,pBlokDisA

              Adds pXpos,pSumX
              Adds pXpos,AlphaXa
              subs pXpos,pOffsetX

              Adds pYpos,pSumY
              Adds pYpos,AlphaYa
              subs pYpos,pOffsetY

              Adds pZpos,pSumZ
              Adds pApos,pSumA
              ret  wcz

''''''''''''''ltEQbt Call'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

lcEQbt        adds pSumX,pXmove   'Adds in Xmove to pSumX
              subs pSumX,pAccDisX 'Xmove minus the acc/dec part, first acceleration already
                                  'added in when loopcnt1==AccTC
              subs pSumX,pAccDisX 'the Deceleration part hasn't happened yet

              adds pSumY,pYmove
              subs pSumY,pAccDisY
              subs pSumY,pAccDisY 'good...

              adds pSumZ,pZmove
              subs pSumZ,pAccDisZ
              subs pSumZ,pAccDisZ 'good...

              adds pSumA,pAmove
              subs pSumA,pAccDisA
              subs pSumA,pAccDisA 'good...

              adds pSumT,pDisT
              subs pSumT,pAccDisT
              subs pSumT,pAccDisT 'good...
              ''''''''''''''''''''''''''''''''''''''''
              ''''''''''''''''''''''''''''''''''''''''
              call #\Xfer2        'move remaining move to old move and zero current move
              'call XferPTR
              ''''''''''''''''''''''''''''''''''''''''
              ''''''''''''''''''''''''''''''''''''''''
              mov pBlockTime,pAccTC       'if new move gets loaded, this gets overwritten
              add pBlockTime,#20         '20? bigger than AccTC
              mov pLoopcnt1,#0

              Testb pAck_out,#1  wz       'move the "move active" bit to the "deceleration active" bit
              bitZ  pAck_out,#2           'move the "move active" bit to the "deceleration active" bit

              testb pExStop,#0  wz        'if exact stop, bit #0 is a 1, Z will be true
              mov   pExStop,#0
     if_z     jmp #down1                  'if exact stop don't load new move yet


              testb  pAck_in,#0 wz        'checks for new move... writes zero if bit is high and new move true...
     if_nz    bitL  pAck_out,#1           'remove "move active bit" if no new move 4/25/2021
     if_nz    jmp #down1                  'if no new move, jump down

              '''''''''''''''''''read in move data from hub''''''''''''''''''''''''''''''''''''''''''''''''''''''''
              setq #24                   'read in new moves down to pSqTC
              rdlong pXmove,ReadPTR      'Xmove,Ymove,Zmove,Amove,Blocktime,AccTC,AckIn,AccDisX,AccDisY,
                                         'AccDisZ,AccDisA,SqTC,ExStop,Sign,Xv,Yv,Zv,Av,
                                         'StT,EndT,DisT,OffsetX,OffsetY,AccDisT,pRad
              '''''''''''''''''read in complete''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
              bitH   pAck_out,#1          'set new "move active" bit
              bitH   pAck_out,#0          'acknowledge reading new move

down1         ret

''============Xfer2 Call======================================================================
Xfer2         mov pDecDisX,pAccDisX
              mov pDecDisY,pAccDisY
              mov pDecDisZ,pAccDisZ
              mov pDecDisA,pAccDisA
              mov pDecDisT,pAccDisT
              mov pRado,pRad
              mov pStTo,pStT
              mov pEndTo,pEndT
              mov pOffsetXo,pOffsetX
              mov pOffsetYo,pOffsetY
              mov pSigno,pSign

Zero2         mov pOffsetX,#0
              mov pOffsetY,#0

              mov pAccDisX,#0             'zero acceleration distance
              mov pAccDisY,#0
              mov pAccDisZ,#0
              mov pAccDisA,#0
              mov pAccDisT,#0

              mov pXmove,#0               'if new move gets loaded, this gets overwritten
              mov pYmove,#0
              mov pZmove,#0
              mov pAmove,#0
              mov pDisT,#0

              mov pRad,#0
              mov pStT,#0
              mov pEndT,#0
              ret

''============ScaleLUT Call======================================================================
ScaleLUT      ABS  tv2,pXpos           'this takes care of Steps/mm conversion
              QMUL tv2,pXscale
              ABS  tv2,pYpos
              QMUL tv2,pYscale
              ABS  tv2,pZpos
              QMUL tv2,pZscale
              ABS  tv2,pApos
              QMUL tv2,pAscale

              REP #4,#4                'load up cordic pipeline
              GETQX tv1
              GETQY tv2
              SETQ  tv2
              QDIV tv1,ScaleDiv        'load cordic pipeline with 4 divisions

              GETQX Xscaled
              GETQX Yscaled
              GETQX Zscaled
              GETQX Ascaled

              testb pXpos, #31 wz
              NegZ  Xscaled
              testb pYpos, #31 wz
              NegZ  Yscaled
              testb pZpos, #31 wz
              NegZ  Zscaled
              testb pApos, #31 wz
              NegZ  Ascaled
              RET
''================================================================================================

PulsesLUT     MOV  sPin, BasePin    'Step pin start number
              MOV  dPin, BasePin
              MOV  DirBit,#0
              ADD  Dpin,#1
              SETD OddPTR,#Xpulse  'base address of Xpulse in D register Bits[17..9] of OddPTR
              SETS OddPTR,#Xscaled 'base address of Xscaled in S register Bits[8..0] of OddPTR
            'REP  #4,#4           'Rep didn't work because of the call??...DJNZ instead.
              MOV tv1,#4
.axis         CALL #\UpDate
              ALTI OddPTR,#%011_011 'increment S and D in OddPTR so it points to Ypulse and Yscaled
              ADD  sPin,#2          'go to next axis step pin
              ADD  dPin,#2          'go to next axis direction pin
              ADD  DirBit,#1
              DJNZ tv1,#.axis        'Just did X, now repeat for Y,Z,A
              RET
              ''''''''''''''''''''''''''''''''''''''

UpDate        TESTP sPin  wc   'test step pin
       if_c   DRVL  sPin       'If step is high, lower it and move to next axis
       if_c   RET              'If step is high, lower it and move to next axis

              TESTB DirBits,DirBit wc
       if_c   MOV   DirSkp,#%0011
       if_nc  MOV   DirSkp,#%1100

              ALTI OddPTR,#%100_100 'Modify "S" and "D" in next instruction so it does Y axis next, then Z
              CMPS Xpulse,Xscaled wcz
       if_z   RET                 'If Yscaled=Ypulse, move to next axis
       if_nc  JMP  #\nDir          'If NC is set if Yscaled < Ypulse

pDir          TESTP dPin wc       'Xscaled > Ypulse  positive direction
              SKIP  DirSkp        'for reversing axis travel direction based on direction bit settings
              DRVL  dPin          'normal dir, if dir pin is wrong, change it
       if_c   RET
              DRVH  dPin          'reverse direction, if dir pin is wrong, change it
       if_nc  RET                       'want dir to be low for a loop before putting out a step
              DRVH  sPin          'if dir pin was current sign, output a pulse on step pin       '
              ALTI OddPTR, #%100_000 'change next instruction "D" to Ypulse or Zpulse if next in line
              ADDS  Xpulse,#1        'and increment x
              RET

nDir          TESTP Dpin wc        'Xscaled < Xpulse  negative direction
              SKIP  DirSkp         'for reversing axis travel direction based on direction bit settings
              DRVH  dPin           'normal dir if dir pin is wrong, change it
       if_nc  RET
              DRVL  dPin           'reverse dir, if dir pin is wrong, change it
       if_c   RET
              DRVH  sPin  'if dir pin was current sign, output a pulse on step pin
              ALTI OddPTR, #%100_000 'change next instruction "D" to Ypulse or Zpulse if next in line
              SUBS  Xpulse,#1
              RET

''===============================================================================================

{     legacy... left this for refrence to see how it worked before using indirect addressing...
Xstp          Testp pXstep wc
      if_c    DRVL  pXstep       'If step is high, lower it and move to next axis
      if_c    JMP #Ystp          'If step is high, lower it and move to next axis

              CMPS Xpulse,Xscaled wcz
      if_z    JMP  #Ystp          'If Xscaled=Xpulse, move to next axis
      if_nc   jmp  #dw1           'C is set if Xscaled<Xpulse, if not set Xscaled>Xpulse

              Testp pXdir wc       'pXscaled > Xpulse
              DRVL  pXdir          'if dir pin is wrong, change it

       if_c   JMP   #Ystp          'want dir to be low for a loop before putting out a step
              DRVH  pXstep         'if dir pin was current sign, output a pulse
       '
              ADDS  Xpulse,#1      'and increment x
              JMP   #Ystp

dw1           Testp pXdir wc       'pXpos < Xpulse
              DRVH  pXdir

      if_nc   JMP   #Ystp          'want dir to be high for a loop before putting out a step
              DRVH  pXstep         'if dir pin was current sign, output a pulse

              SUBS  Xpulse,#1      'and decrement x
 }
''================================================================================================
SoftRsLUT     call #\Xfer2               'this will clear the buffers if it runs a few loops...
              call #\Xfer2               'this will clear the buffers if it runs a few loops..
              mov pSumX,pXpos          'is this ok? 5/4/2021
              mov pSumY,pYpos
              mov pSumZ,pZpos
              mov pSumA,pApos
              mov pblocktime,pAccTC
              add pblocktime,#2
              mov pLoopcnt1,#0
              bitL  pAck_out,#1           'remove "move active bit"
              bitL  pAck_out,#2           'remove "decel active bit"
              bitL  pAck_out,#0           'remove "move read ack"
              SetQ #8                     'output to hub every loop
              wrlong pXpos,WritePTR       'Xpos,Ypos,Zpos,Apos,Xvel,Yvel,Zvel,Avel,Ack_out

srst          rdlong pAck_in,AckPTR        'soft reset
              testb pAck_in,#2   wz
       if_z   jmp #srst                    'sit here till soft reset goes away
              ret
''==================================================================================================
ZipX          rdlong pXpos,ReadPTR         'read G92 Xmove into pXpos
              call #\ScaleLUT
              mov Xpulse,Xscaled
              mov pSumX,pXpos
              JMP #\RaR
              ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
ZipY          add ReadPTR,#4
              rdlong pYpos,ReadPTR         'read G92 Ymove into pYpos
              sub ReadPTR,#4
              call #\ScaleLUT
              mov Ypulse,Yscaled
              mov pSumY,pYpos
              JMP #\Rar
              ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
ZipZ          add ReadPTR,#8
              rdlong pZpos,ReadPTR         'read G92 Zmove into pZpos
              sub ReadPTR,#8
              call #\ScaleLUT
              mov Zpulse,Zscaled
              mov pSumZ,pZpos
              JMP #\RaR
              ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
ZipA          add ReadPTR,#12
              rdlong pApos,ReadPTR         'read G92 Amove into pApos
              sub ReadPTR,#12
              call #\ScaleLUT
              mov Apulse,Ascaled
              mov pSumA,pApos
              JMP #\RaR
              '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
RaR           SetQ #8                      'output updated positions to hub
              wrlong pXpos,WritePTR        'Xpos,Ypos,Zpos,Apos,Xvel,Yvel,Zvel,Avel,Ack_out
              ret

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

PRI vectorlength(x,y) : length | t1,t2,t3,t4

   org
           ABS x
           ABS y
           QMUL x,x
           QMUL y,y
           GETQX t1
           GETQY t3
           GETQX t2
           GETQY t4
           add t1,t2  WC
    if_c   add t3,#1
           add t3,t4
           QSQRT t1,t3
           GETQX length
   end
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI triangleleg(x,hyp) : y | t1,t2,t3,t4

   org
           ABS hyp
           ABS x
           QMUL hyp,hyp
           QMUL x,x
           GETQX t1
           GETQY t3
           GETQX t2
           GETQY t4
           sub t1,t2  WC
    if_c   sub t3,#1
           sub t3,t4
           QSQRT t1,t3
           GETQX y
   end

PRI StreamText()   ''''reading text from a file read into DAT'''''''''''

               if (byte[headPTR] == $f8)
                 StreamTxT := false
               else
                 if(Buffered < 4) 'add to move buffer if buffer is below 3, or wharever, could make this 10 or 20...
                  repeat while (byte[headPTR] ==  10) or (byte[headPTR] ==  13)   'find end of text line
                    headPTR++
                  MDI(headPTR)
                  ''''''''''''''''''advance to <cr><lf>''''''''''''''''''''''''''''''''''''''''''''''''
                  repeat while (byte[headPTR] <>  $f8) and (byte[headPTR] <> 10) and (byte[headPTR] <> 13)
                       headPTR++
                  ''''''''''''''''''get past <cr><lf>''''''''''''''''''''''''''''''''''''''''''''''''''
                  repeat while ((byte[headPTR] == 10) or (byte[headPTR] == 13)) 'get past <cr><lf>
                       headPTR++





PRI ChkSwLmts()

    if xpos > XhiLmt               'testing limits
        XhiLMT := XhiLmt+10         'need to reload staged move, it uses old abs coords, needs new
        Ack_in := Ack_in | SkipM    'set "skip rest of move" bit
        term.str(string("SW HIGH LIMIT X",13,10))
        waitms(50)
        AbsX := Xpos
        AbsY := Ypos
        AbsZ := Zpos
        AbsA := Apos
        Ack_in := Ack_in & !SkipM   'reset "skip rest of move bit"

    if xpos < XloLmt               'testing limits
        XloLMT := XloLmt-10         'need to reload staged move, it uses old abs coords, needs new
        Ack_in := Ack_in | SkipM    'set "skip rest of move" bit
        term.str(string("SW LOW LIMIT X",13,10))
        waitms(50)
        AbsX := Xpos
        AbsY := Ypos
        AbsZ := Zpos
        AbsA := Apos
        Ack_in := Ack_in & !SkipM   'reset "skip rest of move bit"


PRI PullUpLimits()

    wrpin(xHiLmtPin, P_HIGH_15K)
    pinhigh(xHiLmtPin)

    wrpin(xLoLmtPin, P_HIGH_15K)
    pinhigh(xLoLmtPin)

    wrpin(yHiLmtPin, P_HIGH_15K)
    pinhigh(yHiLmtPin)

    wrpin(yLoLmtPin, P_HIGH_15K)
    pinhigh(yLoLmtPin)

    wrpin(zHiLmtPin, P_HIGH_15K)
    pinhigh(zHiLmtPin)

    wrpin(zLoLmtPin, P_HIGH_15K)
    pinhigh(zLoLmtPin)

    wrpin(aHiLmtPin, P_HIGH_15K)
    pinhigh(aHiLmtPin)

    wrpin(aLoLmtPin, P_HIGH_15K)
    pinhigh(aLoLmtPin)

    wrpin(Probe1Pin, P_HIGH_15K)
    pinhigh(Probe1Pin)

    wrpin(Probe2Pin, P_HIGH_15K)
    pinhigh(Probe2Pin)

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI StartUp()| index

   'CntGrbl[0],CntGrbl[1]:= 0,1,2,3,4,5,6,10,11,12,13,20,21,22,23,24,25,26,27,30,31,32,100,101,102,110,111,112,120,121,122,130,131,132
    ParGrbl[0] := 10       'Step pulse usec
    ParFmt[0] := 0         'no decimal places
    Pnum[0]:=0

    ParGrbl[1] := 25       'step idle delay msec
    ParFmt[1] := 0
    Pnum[1] := 1

    ParGrbl[2] := 0        'step port invert mask
    ParFmt[2] := 0
    Pnum[2] := 2

    ParGrbl[3] := 0        'dir port invert mask
    ParFmt[3] := 0
    Pnum[3] := 3

    ParGrbl[4] := 0        'step enable invert
    ParFmt[4] := 0
    Pnum[4] := 4

    ParGrbl[5] := 10       'limit pins invert
    ParFmt[5] := 0
    Pnum[5] := 5

    ParGrbl[6] := 0        'probe pin invert
    ParFmt[6] := 0
    Pnum[6] := 6

    ParGrbl[10] := 1       'status report mask
    ParFmt[10] := 0
    Pnum[7] := 10

    ParGrbl[11] := 10      'Junction deviation mm  0.0010
    ParFmt[11] := 3
    Pnum[8] := 11

    ParGrbl[12] := 2       'arc tolerance mm 0.002
    ParFmt[12] := 3
    Pnum[9] := 12

    ParGrbl[13] := 0       'report inches, boolean
    ParFmt[13] := 0
    Pnum[10] := 13

    ParGrbl[20] := 0       'soft limits, boolean
    ParFmt[20] := 0
    Pnum[11] := 20

    ParGrbl[21] := 0       'hard limits, boolean
    ParFmt[21] := 0
    Pnum[12] := 21

    ParGrbl[22] := 1       'homing cycle, boolean
    ParFmt[22] := 0
    Pnum[13] := 22

    ParGrbl[23] := 0       'homing direction invert mask
    ParFmt[23] := 0
    Pnum[14] := 23

    ParGrbl[24] := 25_000  'homing feed, mm/min 25.000
    ParFmt[24] := 3
    Pnum[15] := 24

    ParGrbl[25] := 500_000 'homing seek, mm/min 500.000
    ParFmt[25] := 3
    Pnum[16] := 25

    ParGrbl[26] := 250     'homing debounce, msec
    ParFmt[26] := 0
    Pnum[17] := 26

    ParGrbl[27] := 1000    'homing pulloff, mm 1.000
    ParFmt[27] := 3
    Pnum[18] := 27

    ParGrbl[30] := 1000      'max spindle speed, RPM
    ParFmt[30] := 0
    Pnum[19] := 30

    ParGrbl[31] := 0         'min spindle speed
    ParFmt[31] := 0
    Pnum[20] := 31

    ParGrbl[32] := 0         'laser mode, boolean
    ParFmt[32] := 0
    Pnum[21] := 32

    ParGrbl[100] := 80_000   '1_000_000 x steps/mm 1000.000
    ParFmt[100] := 3
    Pnum[22] := 100

    ParGrbl[101] := 80_000   'y steps/mm 1000.000
    ParFmt[101] := 3
    Pnum[23] := 101

    ParGrbl[102] := 1_000_000   'z steps/mm 1000.000
    ParFmt[102] := 3
    Pnum[24] := 102

    ParGrbl[103] := 1_000_000   'A steps/mm 250.000
    ParFmt[103] := 3
    'Pnum[24] := 103             'don't output this one

    ParGrbl[110] := 500_000   'x max rate mm/min 500.000
    ParFmt[110] := 3
    Pnum[25] := 110

    ParGrbl[111] := 500_000   'y max rate mm/min 500.000
    ParFmt[111] := 3
    Pnum[26] := 111

    ParGrbl[112] := 500_000   'z max rate mm/min 500.000
    ParFmt[112] := 3
    Pnum[27] := 112

    ParGrbl[120] := 10_000     'x acceleration, mm/sec^2 10.000
    ParFmt[120] := 3
    Pnum[28] := 120

    ParGrbl[121] := 10_000     'y acceleration, mm/sec^2 10.000
    ParFmt[121] := 3
    Pnum[29] := 121

    ParGrbl[122] := 10_000     'z acceleration, mm/sec^2 10.000
    ParFmt[122] := 3
    Pnum[30] := 122

    ParGrbl[130] := 200_000     'x max travel, mm
    ParFmt[130] := 3
    Pnum[31] := 130

    ParGrbl[131] := 200_000     'y max travel, mm
    ParFmt[131] := 3
    Pnum[32] := 131

    ParGrbl[132] := 200_000     'z max travel, mm
    ParFmt[132] := 3
    Pnum[33] := 132

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
PRI ClearBuffer() | index
   index := 0
   repeat while index < 100
       gMtype[index]:= -1
       gAbs[index] := 0
       gPlane[index] := 0
       gUnits[index] := 0
       gCoord[index] := 0
       inputs[index] := 0
       xvalue[index] := 0
       yvalue[index] := 0
       zvalue[index] := 0
       avalue[index] := 0
       ivalue[index] := 0
       jvalue[index] := 0
       kvalue[index] := 0
       rvalue[index] := 0
       svalue[index] := 0
       tvalue[index] := 0
       fvalue[index] := -1
       pvalue[index] := 0
       skips[index] := 0
       index++









''==================================================================================================
{{


  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

}}