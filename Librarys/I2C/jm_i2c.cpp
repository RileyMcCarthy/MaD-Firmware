// automatically generated by spin2cpp v5.9.14 on Sun Aug 07 14:30:13 2022
// command line: C:\spin2cpp\spin2cpp.exe --p2 -o MaD_Firmware/Librarys/I2C/jm_i2c Mad_Firmware/Librarys/I2C/jm_i2c.spin2 

// =================================================================================================
//
//   File....... jm_i2c.spin2
//   Purpose.... Low-level I2C routines for the P2
//   Author..... Jon "JonnyMac" McPhalen
//               Copyright (c) 2020 Jon McPhalen
//               -- see below for terms of use
//   E-mail..... jon.mcphalen@gmail.com
//   Started....  
//   Updated.... 30 JUN 2020
//
// =================================================================================================
// Note: The pin modes drive the high output through a resistor; this simulates the use of a pull-up
//       on the pin.
#define __SPIN2CPP__
#include <propeller2.h>
#include "jm_i2c.h"

#define INLINE__ static inline
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
void jm_i2c::null(void)
{
}

// This is not a top-level object
void jm_i2c::setup(int32_t scl, int32_t sda, int32_t khz, int32_t pullup)
{
  int32_t 	tix, _temp__0000, _tmp__0001;
  // Define I2C SCL (clock) and SDA (data) pins
  // -- khz is bus frequency: 100 (standard), 400 (full), 1000 (fast)
  //    * circuit/connections will affect maximum bus speed
  // -- pullup controls high level drive configuration of SCL and SDA
  // copy pins
  sclpin = scl;
  sdapin = sda;
  // calculate ticks in 1/4 period
  clktix = ( ( (_temp__0000 = Shr__((_clkfreq / (khz * 1000)), 2)), (tix = _temp__0000) ), _temp__0000 );
  _tmp__0001 = pullup;
  if (_tmp__0001 == PU_NONE) {
    goto _case__0002;
  }
  if (_tmp__0001 == PU_1K5) {
    goto _case__0003;
  }
  if (_tmp__0001 == PU_3K3) {
    goto _case__0004;
  }
  goto _case__0005;
  _case__0002: ;
  // use external pull-up
  pullup = 14336;
  goto _endswitch_0001;
  _case__0003: ;
  // 1.5k
  pullup = 2048;
  goto _endswitch_0001;
  _case__0004: ;
  // acts like ~3.3k
  pullup = 8192;
  goto _endswitch_0001;
  _case__0005: ;
  // 15K
  pullup = 4096;
  goto _endswitch_0001;
  _endswitch_0001: ;
  __asm__ volatile(
      "            wrpin   %[pullup], %[scl]\t\n"
  : [pullup] "+r"(pullup)
  : [scl] "r"(scl)
  );
}

int32_t jm_i2c::present(int32_t slaveid)
{
  int32_t result = 0;
  // Pings device, returns true if device on bus.
  start();
  result = -(write(slaveid) == ACK);
  return result;
}

void jm_i2c::wait(int32_t slaveid)
{
  int32_t 	ackbit;
  // Waits for device to be ready for new command.
  // -- Note: Use present() to detect device before using wait()
  do {
    start();
    ackbit = write(slaveid);
  } while (!(ackbit == ACK));
}

void jm_i2c::start(void)
{
  int32_t 	scl, sda, tix;
  // Create I2C start sequence
  // -- will wait if I2C bus SCL pin is held low
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
      "            drvh    %[sda]\t\n"
  : [sda] "+r"(sda)
  :  );
}

int32_t jm_i2c::write(int32_t i2cbyte)
{
  int32_t 	scl, sda, tix;
  int32_t ackbit = 0;
  // Write byte to I2C bus
  // -- leaves SCL low
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
      "            shl     %[i2cbyte], #24\t\n"
  : [i2cbyte] "+r"(i2cbyte)
  :  );
  return ackbit;
}

int32_t jm_i2c::wr_block(int32_t p_block, int32_t count)
{
  int32_t 	scl, sda, tix, i2cbyte;
  int32_t ackbit = 0;
  // Write count bytes from p_block to I2C bus
  // -- p_block is pointer to bytes
  // -- leaves SCL low
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
  :  :  );
  return ackbit;
}

int32_t jm_i2c::read(int32_t ackbit)
{
  int32_t 	scl, sda, tix;
  int32_t i2cbyte = 0;
  // Read byte from I2C bus
  // -- ackbit is state of ack bit
  //    * usually NAK for last byte read
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
      "            drvh    %[sda]\t\n"
  : [sda] "+r"(sda)
  :  );
  return i2cbyte;
}

void jm_i2c::rd_block(int32_t p_block, int32_t count, int32_t ackbit)
{
  int32_t 	i2cbyte, scl, sda, tix;
  // Read count bytes from I2C bus
  // -- p_block is pointer to storage location for bytes
  // -- ackbit is state of ack for final byte read
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
  :  :  );
}

void jm_i2c::stop(void)
{
  int32_t 	scl, sda, tix;
  // Create I2C stop sequence
  // -- allows for clock stretch
  // copy pins & timing
  scl = sclpin;
  sda = sdapin;
  tix = clktix;
  __asm__ volatile(
      "            drvl    %[sda]\t\n"
  : [sda] "+r"(sda)
  :  );
}

/*  license  */
/* 

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

 */
