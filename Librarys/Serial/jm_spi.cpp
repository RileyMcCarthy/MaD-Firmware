// automatically generated by spin2cpp v5.9.14 on Sun Aug 07 14:44:00 2022
// command line: C:\spin2cpp\spin2cpp.exe --p2 -o MaD_Firmware/Librarys/Serial/jm_spi Mad_Firmware/Librarys/Serial/jm_spi.spin2 

// =================================================================================================
//
//   File....... jm_ez_spi.spin2
//   Purpose.... Smart pin Mode 0 SPI routines
//   Author..... Jon "JonnyMac" McPhalen
//               Copyright (c) 2020 Jon McPhalen
//               -- see below for terms of use
//   E-mail..... jon.mcphalen@gmail.com
//   Started....
//   Updated.... 01 SEP 2020
//
//   {$P2} 
//
// =================================================================================================
#define __SPIN2CPP__
#include <propeller2.h>
#include "jm_spi.h"

#define INLINE__ static inline
#define Yield__() __asm__ volatile( "" ::: "memory" )
INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a>>b); }
void jm_spi::null(void)
{
}

// This is not a top object                                                        
int32_t jm_spi::start(int32_t sdipin, int32_t sdopin, int32_t sckpin, int32_t khz)
{
  int32_t 	m, x;
  int32_t result = 0;
  // Configure P2 smart pins for SPI coms
  // -- sdipin is input from external device (-1 if not used)
  // -- sdopin is output to external device  (-1 if not used)
  // -- sckpin is clock output
  // -- khz is clock frequence in kilohertz  (1000 = 1MHz)                                                        
  stop();
  if ((sdipin == sdopin) || (sckpin < 0)) {
    // validate pins
    return 0;
  }
  // save pins
  sdi = sdipin;
  sdo = sdopin;
  sck = sckpin;
  if (sdi >= 0) {
    // spi rx mode                         
    m = 58;
    // add SCK offset (B pin)              
    m |= (((sck - sdi) & 0x7) << 24);
    // sample ahead of b pin rise, 8 bits  
    x = 0x0 | (8 - 1);
    // configure smart pin                                                                   
    ;
    // disable until used
    ;
  }
  if (sdo >= 0) {
    // spi tx mode
    m = 64 | 56;
    // add SCK offset (B pin)
    m |= (((sck - sdo) & 0x7) << 24);
    // start/stop mode, 8 bits
    x = 0x20 | (8 - 1);
    // configure smart pin  
    ;
    // disable until used 
    ;
  }
  // pulses for spi clock   
  m = 64 | 8;
  // ticks in period        
  x = (x & 0xffff0000) | (((Min__((Max__(2, (_clkfreq / (khz * 1000)))), 65535)) & 0xffff) << 0);
  // ticks in low cycle (50%)      
  x = (x & 0xffff) | (((Shr__(((Shr__(x, 0)) & 0xffff), 1)) & 0xffff) << 16);
  // configure smart pin                                                         
  ;
  setup = -1;
  return setup;
}

void jm_spi::stop(void)
{
  // Clears SPI smart pins if configured
  if (setup) {
    // configured?
    if (sdi >= 0) {
      // clear smart pins
      ;
    }
    if (sdo >= 0) {
      ;
    }
    ;
    setup = 0;
  }
  // mark pins as unused
  { int32_t _fill__0001; int32_t *_ptr__0003 = (int32_t *)&sdi; int32_t _val__0002 = (-1); for (_fill__0001 = 3; _fill__0001 > 0; --_fill__0001) {  *_ptr__0003++ = _val__0002; } };
}

int32_t jm_spi::shiftin(int32_t mode, int32_t bits)
{
  int32_t value = 0;
  // Shift data in from a synchronous serial device
  // -- mode is bit order: LSBFIRST or MSBFIRST
  // -- bits in the number of bits to shift
  if (sdi < 0) {
    // abort if di not defined
    return 0;
  }
  // reset di
  ;
  // configure di sampling/bits
  _wxpin(sdi, 0x0 | (bits - 1));
  // enable di
  ;
  // start clocking data
  _wypin(sck, bits);
  while (!()) {
    Yield__();
  }
  // wait until clocks finished
  // get value
  value = ;
  if (mode == LSBFIRST) {
    // align lsb
    value = Shr__(value, (32 - bits));
  } else {
    // flip to align lsb
    value = __builtin_propeller_rev(value, 32 - (31 + 1));
    if (bits < 32) {
      // clear unused bits
      value = ((uint32_t)value << (32 - bits)) >> (32 - bits);
    }
  }
  return value;
}

void jm_spi::shiftout(int32_t mode, int32_t value, int32_t bits)
{
  // Shift data out to a synchronous serial device 
  // -- mode is bit order: LSBFIRST or MSBFIRST 
  // -- value is shifted out
  // -- bits in the number of bits to shift
  if (sdo < 0) {
    // abort if do not defined
    return;
  }
  if (mode == MSBFIRST) {
    // flip to output from LSB end
    if (bits < 32) {
      // adjust alignment if needed
      value = value << (32 - bits);
    }
    value = __builtin_propeller_rev(value, 32 - (31 + 1));
  }
  // configure do bits
  _wxpin(sdo, 0x20 | (bits - 1));
  // load value
  _wypin(sdo, value);
  // enable do
  ;
  // start clocking data
  _wypin(sck, bits);
  while (!()) {
    Yield__();
  }
  // wait for clocking to finish
  // disable do 
  ;
}

int32_t jm_spi::shiftio(int32_t mode, int32_t outval, int32_t bits)
{
  int32_t inval = 0;
  // Shift outval to a synchronous serial device while receiving inval
  // -- mode is bit order: LSBFIRST or MSBFIRST 
  // -- bits in the number of bits to shift
  if ((sdi < 0) || (sdo < 0)) {
    // abort if di and do not defined
    return 0;
  }
  if (mode == MSBFIRST) {
    if (bits < 32) {
      // adjust alignment if needed
      outval = outval << (32 - bits);
    }
    // flip to output from LSB end   
    outval = __builtin_propeller_rev(outval, 32 - (31 + 1));
  }
  // configure do bits
  _wxpin(sdo, 0x20 | (bits - 1));
  // load value
  _wypin(sdo, outval);
  // enable do
  ;
  // reset di
  ;
  // configure di sampling/bits
  _wxpin(sdi, 0x0 | (bits - 1));
  // enable di
  ;
  // start clocking data
  _wypin(sck, bits);
  while (!()) {
    Yield__();
  }
  // wait for clocking to finish
  // disable do 
  ;
  // get inval
  inval = ;
  if (mode == LSBFIRST) {
    // align lsb
    inval = Shr__(inval, (32 - bits));
  } else {
    // flip to align lsb
    inval = __builtin_propeller_rev(inval, 32 - (31 + 1));
    if (bits < 32) {
      // clear unused bits
      inval = ((uint32_t)inval << (32 - bits)) >> (32 - bits);
    }
  }
  return inval;
}

/*  license  */
/* 

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */
