// automatically generated by spin2cpp v5.9.14 on Sun Aug 07 12:49:50 2022
// command line: C:\spin2cpp\spin2cpp.exe --p2 -o Librarys/Serial/jm_fullduplexserial Librarys/Serial/jm_fullduplexserial.spin2

// =================================================================================================
//
//   File....... jm_fullduplexserial.spin2
//   Purpose.... Buffered serial communications using smart pins
//               -- mostly matches FullDuplexSerial from P1
//               -- does NOT support half-duplex communications using shared RX/TX pin
//   Authors.... Jon McPhalen
//               -- based on work by Chip Gracey
//               -- see below for terms of use
//   E-mail..... jon.mcphalen@gmail.com
//   Started....
//   Updated.... 04 JAN 2022
//               -- f___() changed to fx__() to fix conflict with Propeller Tool 2.6.x
//
//   {$P2}
//
// =================================================================================================
/*

   Note: Buffer size no longer has to be power-of-2 integer.

   Note: The dec(), bin(), and hex() methods will no longer require the digits parameter as
         in older versions of FullDuplexSerial. Use fdec(), fbin(), and fhex() for code that
         requires a specific field width.


   The smart pin uarts use a 16-bit value for baud timing which can limit low baud rates for
   some system frequencies -- beware of these limits when connecting to older devices.

    Baud     20MHz    40MHz    80MHz    100MHz    200MHz    300MHz
   ------    -----    -----    -----    ------    ------    ------
      300       No       No       No        No        No        No
      600      Yes       No       No        No        No        No
     1200      Yes      Yes       No        No        No        No
     2400      Yes      Yes      Yes       Yes        No        No
     4800      Yes      Yes      Yes       Yes       Yes       Yes

 */
#include <stdlib.h>
#include <string.h>
#define __SPIN2CPP__
#include <propeller2.h>
#include "jm_fullduplexserial.h"

#define INLINE__ static inline
#define Yield__() __asm__ volatile("" :: \
                                       : "memory")
INLINE__ int32_t Min__(int32_t a, int32_t b) { return a < b ? a : b; }
INLINE__ int32_t Max__(int32_t a, int32_t b) { return a > b ? a : b; }
INLINE__ int32_t Shr__(uint32_t a, uint32_t b) { return (a >> b); }
INLINE__ int32_t Lookdown__(int32_t x, int32_t b, int32_t a[], int32_t n)
{
  int32_t i, r;
  r = 0;
  for (i = 0; i < n; i++)
  {
    if (a[i] == x)
    {
      r = i + b;
      break;
    }
  };
  return r;
}

char jm_fullduplexserial::dat[] = {
    0x28,
    0x06,
    0x64,
    0xfd,
    0x00,
    0x3b,
    0x04,
    0xfb,
    0x1f,
    0x3a,
    0x14,
    0xf4,
    0x0c,
    0x00,
    0xb0,
    0x3d,
    0x1f,
    0x3c,
    0x14,
    0xf4,
    0x2c,
    0x00,
    0xb0,
    0x3d,
    0xec,
    0xff,
    0x9f,
    0xfd,
    0x40,
    0x3a,
    0x70,
    0xfd,
    0x2d,
    0x00,
    0x64,
    0x3d,
    0x1d,
    0x46,
    0x88,
    0xfa,
    0x18,
    0x46,
    0x44,
    0xf0,
    0x1f,
    0x42,
    0x00,
    0xf6,
    0x04,
    0x45,
    0x04,
    0xfb,
    0x22,
    0x42,
    0x00,
    0xf1,
    0x21,
    0x46,
    0x40,
    0xfc,
    0xff,
    0x44,
    0x04,
    0xf7,
    0x04,
    0x45,
    0x64,
    0x0c,
    0x1e,
    0x42,
    0x98,
    0xfa,
    0x2d,
    0x00,
    0x64,
    0xcd,
    0x06,
    0x43,
    0x04,
    0xfb,
    0x07,
    0x45,
    0x04,
    0xfb,
    0x22,
    0x42,
    0x08,
    0xf2,
    0x2d,
    0x00,
    0x64,
    0xad,
    0x20,
    0x42,
    0x00,
    0xf6,
    0x22,
    0x42,
    0x00,
    0xf1,
    0x21,
    0x46,
    0xc0,
    0xfa,
    0x1e,
    0x46,
    0x20,
    0xfc,
    0xff,
    0x44,
    0x04,
    0xf7,
    0x07,
    0x45,
    0x64,
    0x0c,
};
void jm_fullduplexserial::null(void)
{
}

// This is not a top-level object
int32_t jm_fullduplexserial::tstart(int32_t baud)
{
  int32_t result = 0;
  // Start FDS with default pins/mode for terminal (e.g., PST)
  return start(PGM_RX, PGM_TX, 0, baud);
}

int32_t jm_fullduplexserial::start(int32_t rxpin, int32_t txpin, int32_t mode, int32_t baud)
{
  int32_t baudcfg, spmode, _tmp__0000;
  int32_t result = 0;
  // Start simple serial coms on rxpin and txpin at baud
  // -- rxpin... receive pin (-1 if not used)
  // -- txpin... transmit pin (-1 if not used)
  // -- mode.... %0xx1 = invert rx
  //             %0x1x = invert tx
  //             %01xx = open-drain/open-source tx
  stop();
  if (rxpin == txpin)
  {
    // pin must be unique
    return 0;
  }
  // save pins
  rxp = rxpin;
  txp = txpin;
  // point to buffers
  rxhub = (int32_t)(rxbuf);
  txhub = (int32_t)(txbuf);
  // tix to transmit one byte
  txdelay = (_clkfreq / baud) * 11;
  // set bit timing
  baudcfg = &0xfffffc00;
  // set bits (8)
  baudcfg |= (8 - 1);
  if (rxp >= 0)
  {
    // configure rx pin if used
    spmode = 62;
    if ((Shr__(mode, 0)) & 0x1)
    {
      spmode |= 32768;
    };
  }
  if (txp >= 0)
  {
    // configure tx pin if used
    spmode = 60 | 64;
    _tmp__0000 = (Shr__(mode, 1)) & 0x3;
    if (_tmp__0000 == 1)
    {
      goto _case__0018;
    }
    if (_tmp__0000 == 2)
    {
      goto _case__0019;
    }
    if (_tmp__0000 == 3)
    {
      goto _case__0020;
    }
    goto _endswitch_0017;
  _case__0018:;
    spmode |= 16384;
    goto _endswitch_0017;
  _case__0019:;
    // requires external pull-up
    spmode |= 14336;
    goto _endswitch_0017;
  _case__0020:;
    // requires external pull-down
    spmode |= (16384 | 1792);
    goto _endswitch_0017;
  _endswitch_0017:;
    ;
  }
  // start uart manager cog
  cog = _cognew((int32_t)(((int32_t *)&dat[0])), (int32_t)(&rxp)) + 1;
  return cog;
}

void jm_fullduplexserial::stop(void)
{
  // Stop serial driver
  // -- frees a cog if driver was running
  if (cog)
  {
    // cog active?
    //  yes, shut it down
    _cogstop(cog - 1);
    //  and mark stopped
    cog = 0;
  }
  // reset object globals
  {
    int32_t _fill__0023;
    int32_t *_ptr__0025 = (int32_t *)&rxp;
    int32_t _val__0024 = (-1);
    for (_fill__0023 = 2; _fill__0023 > 0; --_fill__0023)
    {
      *_ptr__0025++ = _val__0024;
    }
  };
  memset((void *)(&rxhub), 0, sizeof(int32_t) * 7);
}

int32_t jm_fullduplexserial::rx(void)
{
  int32_t b = 0;
  // Pulls byte from receive buffer if available
  // -- will wait if buffer is empty
  while (rxtail == rxhead)
  {
    Yield__();
  }
  // hold while buffer empty
  // get a byte
  b = rxbuf[rxtail];
  if ((++rxtail) == BUF_SIZE)
  {
    // update tail pointer
    rxtail = 0;
  }
  return b;
}

int32_t jm_fullduplexserial::rxcheck(void)
{
  int32_t b = 0;
  // Pulls byte from receive buffer if available
  // -- returns -1 if buffer is empty
  if (rxtail != rxhead)
  {
    // something in buffer?
    // get it
    b = rxbuf[rxtail];
    if ((++rxtail) == BUF_SIZE)
    {
      // update tail pointer
      rxtail = 0;
    }
  }
  else
  {
    // mark no byte available
    b = EOF;
  }
  return b;
}

int32_t jm_fullduplexserial::rxtime(int32_t ms)
{
  int32_t mstix, t, _temp__0000;
  int32_t b = 0;
  // Wait ms milliseconds for a byte to be received
  // -- returns -1 if no byte received, $00..$FF if byte
  mstix = _clkfreq / 1000;
  t = _cnt();
  while (!(-(-((((_temp__0000 = rxcheck()), (b = _temp__0000)), _temp__0000) >= 0) != 0) | -(-(((_cnt() - t) / mstix) >= ms) != 0)))
  {
    Yield__();
  }
  return b;
}

int32_t jm_fullduplexserial::rxtix(int32_t tix)
{
  int32_t t, _temp__0000;
  int32_t b = 0;
  // Waits tix clock ticks for a byte to be received
  // -- returns -1 if no byte received
  t = _cnt();
  while (!(-(-((((_temp__0000 = rxcheck()), (b = _temp__0000)), _temp__0000) >= 0) != 0) | -(-((_cnt() - t) >= tix) != 0)))
  {
    Yield__();
  }
  return b;
}

int32_t jm_fullduplexserial::available(void)
{
  int32_t count = 0;
  // Returns # of bytes waiting in rx buffer
  if (rxtail != rxhead)
  {
    // if byte(s) available
    // get count
    count = rxhead - rxtail;
    if (count < 0)
    {
      // fix for wrap around
      count = count + BUF_SIZE;
    }
  }
  return count;
}

void jm_fullduplexserial::rxflush(void)
{
  // Flush receive buffer
  while (rxcheck() >= 0)
  {
    Yield__();
  }
}

void jm_fullduplexserial::tx(int32_t b)
{
  int32_t n;
  // Move byte into transmit buffer if room is available
  // -- will wait if buffer is full
  while (1)
  {
    // bytes in buffer
    n = txhead - txtail;
    if (n < 0)
    {
      // fix for index wrap-around
      n = n + BUF_SIZE;
    }
    if (n < (BUF_SIZE - 1))
    {
      break;
    }
  }
  // move to buffer
  txbuf[txhead] = b;
  if ((++txhead) == BUF_SIZE)
  {
    // update head pointer
    txhead = 0;
  }
}

void jm_fullduplexserial::txn(int32_t b, int32_t n)
{
  int32_t _idx__0000;
  // Emit byte n times
  for (_idx__0000 = n; _idx__0000 != 0; --_idx__0000)
  {
    tx(b);
  }
}

void jm_fullduplexserial::str(int32_t p_str)
{
  int32_t _idx__0000;
  // Emit z-string at p_str
  for (_idx__0000 = strlen((const char *)p_str); _idx__0000 != 0; --_idx__0000)
  {
    tx(((char *)(p_str++))[0]);
  }
}

void jm_fullduplexserial::substr(int32_t p_str, int32_t len)
{
  int32_t b, _idx__0000;
  // Emit len characters of string at p_str
  // -- aborts if end of string detected
  for (_idx__0000 = len; _idx__0000 != 0; --_idx__0000)
  {
    b = ((char *)(p_str++))[0];
    if (b > 0)
    {
      tx(b);
    }
    else
    {
      break;
    }
  }
}

void jm_fullduplexserial::padstr(int32_t p_str, int32_t width, int32_t padchar)
{
  int32_t len, afw;
  // Emit p_str as padded field of width characters
  // -- pad is character to use to fill out field
  // -- positive width causes right alignment
  // -- negative width causes left alignment
  len = strlen((const char *)p_str);
  afw = abs(width);
  if (len >= afw)
  {
    // string wider than field?
    //  yes, truncate
    substr(p_str, afw);
  }
  else
  {
    if (width > 0)
    {
      // right alignment?
      txn(padchar, width - len);
      str(p_str);
    }
    else
    {
      // left alignment
      str(p_str);
      txn(padchar, afw - len);
    }
  }
}

void jm_fullduplexserial::txflush(void)
{
  // Wait for transmit buffer to empty
  // -- will delay one byte period after buffer is empty
  while (!(txtail == txhead))
  {
    Yield__();
  }
  // let buffer empty
  // delay for last byte
  ;
}

/*  formatted strings commands  */
/*
    Escaped characters

      \\          backslash char
      \%          percent char
      \q          double quote
      \b          backspace
      \t          tab (horizontal)
      \n          new line (vertical tab)
      \r          carriage return
      \xnn        arbitrary ASCII character (nn is hexadecimal) ' added 17 AUG 21
      \nnn        arbitrary ASCII character (nnn is decimal)


    Formatted arguments

      %w.pf       print argument as decimal width decimal point
      %[w[.p]]d   print argument as decimal
      %[w[.p]]u   print argument as unsigned decimal
      %[w[.p]]x   print argument as hex
      %[w[.p]]o   print argument as octal
      %[w[.p]]q   print argument as quarternary
      %[w[.p]]b   print argument as binary
      %[w]s       print argument as string
      %[w]c       print argument as character (

                  -- w is field width
                     * positive w causes right alignment in field
                     * negative w causes left alignment in field
                  -- %ws aligns s in field (may truncate)
                  -- %wc prints w copies of c
                  -- p is precision characters
                     * number of characters to use, aligned in field
                       -- prefix with 0 if needed to match p
                       -- for %w.pf, p is number of digits after decimal point
 */
void jm_fullduplexserial::fstr0(int32_t p_str)
{
  // Emit string with formatting characters.
  format(p_str, 0);
}

void jm_fullduplexserial::fstr1(int32_t p_str, int32_t arg1)
{
  int32_t _parm__0000[2];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  // Emit string with formatting characters and one argument.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::fstr2(int32_t p_str, int32_t arg1, int32_t arg2)
{
  int32_t _parm__0000[3];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  _parm__0000[2] = arg2;
  // Emit string with formatting characters and two arguments.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::fstr3(int32_t p_str, int32_t arg1, int32_t arg2, int32_t arg3)
{
  int32_t _parm__0000[4];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  _parm__0000[2] = arg2;
  _parm__0000[3] = arg3;
  // Emit string with formatting characters and three arguments.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::fstr4(int32_t p_str, int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
{
  int32_t _parm__0000[5];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  _parm__0000[2] = arg2;
  _parm__0000[3] = arg3;
  _parm__0000[4] = arg4;
  // Emit string with formatting characters and four arguments.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::fstr5(int32_t p_str, int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5)
{
  int32_t _parm__0000[6];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  _parm__0000[2] = arg2;
  _parm__0000[3] = arg3;
  _parm__0000[4] = arg4;
  _parm__0000[5] = arg5;
  // Emit string with formatting characters and five arguments.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::fstr6(int32_t p_str, int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6)
{
  int32_t _parm__0000[7];
  _parm__0000[0] = p_str;
  _parm__0000[1] = arg1;
  _parm__0000[2] = arg2;
  _parm__0000[3] = arg3;
  _parm__0000[4] = arg4;
  _parm__0000[5] = arg5;
  _parm__0000[6] = arg6;
  // Emit string with formatting characters and six arguments.
  format(_parm__0000[0], (int32_t)(&_parm__0000[1]));
}

void jm_fullduplexserial::format(int32_t p_str, int32_t p_args)
{
  int32_t idx, c, asc, field, digits;
  static int32_t look__0021[] = {
      100,
      117,
      102,
      98,
      113,
      111,
      120,
  };

  // Emit formatted string with escape sequences and embedded values
  // -- p_str is a pointer to the format control string
  // -- p_args is pointer to array of longs that hold field values
  //    * field values can be numbers, characters, or pointers to strings
  // value index
  idx = 0;
  while (1)
  {
    c = ((char *)(p_str++))[0];
    if (c == 0)
    {
      return;
    }
    else
    {
      if (c == '\\')
      {
        c = lower(((char *)(p_str++))[0]);
        if (c == '\\')
        {
          tx('\\');
        }
        else
        {
          if (c == '%')
          {
            tx('%');
          }
          else
          {
            if (c == 'q')
            {
              tx(34);
            }
            else
            {
              if (c == 'b')
              {
                tx(BKSP);
              }
              else
              {
                if (c == 't')
                {
                  tx(TAB);
                }
                else
                {
                  if (c == 'n')
                  {
                    tx(LF);
                  }
                  else
                  {
                    if (c == 'r')
                    {
                      tx(CR);
                    }
                    else
                    {
                      if (c == 'x')
                      {
                        {
                          Tuple2__ tmp__ = get_hex(p_str);
                          p_str = tmp__.v0;
                          asc = tmp__.v1;
                        };
                        if ((asc >= 0) && (asc <= 255))
                        {
                          tx(asc);
                        }
                      }
                      else
                      {
                        if ((c >= '0') && (c <= '9'))
                        {
                          (--p_str);
                          {
                            Tuple3__ tmp__ = get_nargs(p_str);
                            p_str = tmp__.v0;
                            asc = tmp__.v1;
                          };
                          if ((asc >= 0) && (asc <= 255))
                          {
                            tx(asc);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      else
      {
        if (c == '%')
        {
          {
            Tuple3__ tmp__ = get_nargs(p_str);
            p_str = tmp__.v0;
            field = tmp__.v1;
            digits = tmp__.v2;
          };
          c = lower(((char *)(p_str++))[0]);
          if (Lookdown__(c, 1, look__0021, 7))
          {
            str(nstr.fmt_number(((int32_t *)p_args)[(idx++)], c, digits, field, ' '));
          }
          else
          {
            if (c == 's')
            {
              str(nstr.padstr(((int32_t *)p_args)[(idx++)], field, ' '));
            }
            else
            {
              if (c == 'c')
              {
                txn(((int32_t *)p_args)[(idx++)], Max__((abs(field)), 1));
              }
            }
          }
        }
        else
        {
          tx(c);
        }
      }
    }
  }
}

int32_t jm_fullduplexserial::lower(int32_t c)
{
  int32_t result = 0;
  if ((c >= 'A') && (c <= 'Z'))
  {
    c = c + 32;
  }
  return c;
}

Tuple2__ jm_fullduplexserial::get_hex(int32_t p_str)
{
  int32_t c, _idx__0000;
  int32_t p_str1;
  int32_t value;
  static int32_t look__0022[] = {
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      97,
      98,
      99,
      100,
      101,
      102,
  };

  // added 17 AUG 2021 for \xNN
  // Extract 1- or 2-digit hex value from p_str
  for (_idx__0000 = 0; _idx__0000 < 2; _idx__0000++)
  {
    c = lower(((char *)(p_str++))[0]);
    c = Lookdown__(c, 1, look__0022, 16);
    if (c > 0)
    {
      value = (value << 4) | (c - 1);
    }
    else
    {
      break;
    }
  }
  p_str1 = p_str;
  return MakeTuple2__(p_str1, value);
}

Tuple3__ jm_fullduplexserial::get_nargs(int32_t p_str)
{
  int32_t c, sign;
  int32_t p_str1;
  int32_t val1;
  int32_t val2;
  // Parse one or two numbers from string in n, -n, n.n, or -n.n format
  // -- dpoint separates values
  // -- only first # may be negative
  // -- returns pointer to 1st char after value(s)
  // check for negative on first value
  c = ((char *)p_str)[0];
  if (c == '-')
  {
    sign = -1;
    (++p_str);
  }
  else
  {
    sign = 0;
  }
  while (1)
  {
    // get first value
    c = ((char *)(p_str++))[0];
    if ((c >= '0') && (c <= '9'))
    {
      val1 = (val1 * 10) + (c - '0');
    }
    else
    {
      if (sign)
      {
        val1 = -val1;
      }
      break;
    }
  }
  if (c == '.')
  {
    // if dpoint
    while (1)
    {
      //  get second value
      c = ((char *)(p_str++))[0];
      if ((c >= '0') && (c <= '9'))
      {
        val2 = (val2 * 10) + (c - '0');
      }
      else
      {
        break;
      }
    }
  }
  // back up to non-digit
  p_str1 = p_str - 1;
  return MakeTuple3__(p_str1, val1, val2);
}

void jm_fullduplexserial::fmt_number(int32_t value, int32_t base, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value converted to number in padded field
  // -- value is converted using base as radix
  //    * 99 for decimal with digits after decimal point
  // -- digits is max number of digits to use
  // -- width is width of final field (max)
  // -- pad is character that fills out field
  str(nstr.fmt_number(value, base, digits, width, pad));
}

void jm_fullduplexserial::dec(int32_t value)
{
  // Emit value as decimal
  str(nstr.itoa(value, 10, 0));
}

void jm_fullduplexserial::fxdec(int32_t value, int32_t digits)
{
  // Emit value as decimal using fixed # of digits
  // -- may add leading zeros
  str(nstr.itoa(value, 10, digits));
}

void jm_fullduplexserial::jdec(int32_t value, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value as decimal using fixed # of digits
  // -- aligned in padded field (negative width to left-align)
  // -- digits is max number of digits to use
  // -- width is width of final field (max)
  // -- pad is character that fills out field
  str(nstr.fmt_number(value, 'd', digits, width, pad));
}

void jm_fullduplexserial::dpdec(int32_t value, int32_t dp)
{
  // Emit value as decimal with decimal point
  // -- dp is number of digits after decimal point
  str(nstr.dpdec(value, dp));
}

void jm_fullduplexserial::jdpdec(int32_t value, int32_t dp, int32_t width, int32_t pad)
{
  // Emit value as decimal with decimal point
  // -- aligned in padded field (negative width to left-align)
  // -- dp is number of digits after decimal point
  // -- width is width of final field (max)
  // -- pad is character that fills out field
  str(nstr.fmt_number(value, 'f', dp, width, pad));
}

void jm_fullduplexserial::hex(int32_t value)
{
  // Emit value as hexadecimal
  str(nstr.itoa(value, 16, 0));
}

void jm_fullduplexserial::fxhex(int32_t value, int32_t digits)
{
  // Emit value as hexadecimal using fixed # of digits
  str(nstr.itoa(value, 16, digits));
}

void jm_fullduplexserial::jhex(int32_t value, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value as quarternary using fixed # of digits
  // -- aligned inside field
  // -- pad fills out field
  str(nstr.fmt_number(value, 'x', digits, width, pad));
}

void jm_fullduplexserial::oct(int32_t value)
{
  // Emit value as octal
  str(nstr.itoa(value, 8, 0));
}

void jm_fullduplexserial::fxoct(int32_t value, int32_t digits)
{
  // Emit value as octal using fixed # of digits
  str(nstr.itoa(value, 8, digits));
}

void jm_fullduplexserial::joct(int32_t value, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value as octal using fixed # of digits
  // -- aligned inside field
  // -- pad fills out field
  str(nstr.fmt_number(value, 'o', digits, width, pad));
}

void jm_fullduplexserial::qrt(int32_t value)
{
  // Emit value as quarternary
  str(nstr.itoa(value, 4, 0));
}

void jm_fullduplexserial::fxqrt(int32_t value, int32_t digits)
{
  // Emit value as quarternary using fixed # of digits
  str(nstr.itoa(value, 4, digits));
}

void jm_fullduplexserial::jqrt(int32_t value, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value as quarternary using fixed # of digits
  // -- aligned inside field
  // -- pad fills out field
  str(nstr.fmt_number(value, 'q', digits, width, pad));
}

void jm_fullduplexserial::bin(int32_t value)
{
  // Emit value as binary
  str(nstr.itoa(value, 2, 0));
}

void jm_fullduplexserial::fxbin(int32_t value, int32_t digits)
{
  // Emit value as binary using fixed # of digits
  str(nstr.itoa(value, 2, digits));
}

void jm_fullduplexserial::jbin(int32_t value, int32_t digits, int32_t width, int32_t pad)
{
  // Emit value as binary using fixed # of digits
  // -- aligned inside field
  // -- pad fills out field
  str(nstr.fmt_number(value, 'b', digits, width, pad));
}

/*  license  */
/*

  Terms of Use: MIT License

  Permission is hereby granted, free of charge, to any person obtaining a copy of this
  software and associated documentation files (the "Software"), to deal in the Software
  without restriction, including without limitation the rights to use, copy, modify,
  merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
  permit persons to whom the Software is furnished to do so, subject to the following
  conditions:

  The above copyright notice and this permission notice shall be included in all copies
  or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
  PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
  CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
  OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 */
