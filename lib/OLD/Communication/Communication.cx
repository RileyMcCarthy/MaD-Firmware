#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <propeller2.h>
#include "Communication.h"
#include "StateMachine.h"
#include "JsonEncoder.h"
#include "JsonDecoder.h"
#include "Debug.h"
#include "app_motion.h"
#include "app_monitor.h"
#include "IO_staticQueue.h"
#include "dev_nvram.h"
#include "CRC.h"
#include "FullDuplexSerial.h"
#include "watchdog.h"
#include "IO_digitalPin.h"

/* Command structure
 * w<7 cmd bits> <N> <N data>... <CRC>
 * ________ ________ ________
 * <data> = raw data send/recieved depending on w bit
 * <CRC> = check
 */

#define COMMUNICATION_MEMORY_SIZE 8000
static long comm_stack[COMMUNICATION_MEMORY_SIZE];

static FullDuplexSerial fds;

static Notification notification_buffer[MAX_SIZE_NOTIFICATION_BUFFER];
static IO_staticQueue notification_queue;

static bool notification_initialized = false;
static MachineProfile machineProfile;

typedef enum PeriodicMessages
{
    PERIODIC_MESSAGE_DATA,
    PERIODIC_MESSAGE_STATE,
    PERIOD_MESSAGE_COUNT,
} PeriodicMessages;

typedef struct
{
    int32_t gaugeLengthMM;
} app_communication_outputs_t;

typedef struct
{
    app_communication_outputs_t stagedOutputs;
    app_communication_outputs_t outputs; // threadsafe
} app_communication_data_t;

app_communication_data_t app_communication_data;

// Flexprop doesnt support designated initializers, need to use this method :(
// Tedious cause we need to keep the order of the struct the same as the enum
static PeriodicMessage periodic_messages[PERIOD_MESSAGE_COUNT] = {
    {
        // PERIODIC_MESSAGE_DATA
        100,      // period
        0,        // last sent
        CMD_DATA, // command
    },
    {
        // PERIODIC_MESSAGE_STATE
        1000,      // period
        0,         // last sent
        CMD_STATE, // command
    },
};

void notification_init()
{
    if (IO_staticQueue_init(&notification_queue, notification_buffer, MAX_SIZE_NOTIFICATION_BUFFER, sizeof(Notification)))
    {
        notification_initialized = true;
    }
}

void notification_add_debug(const char *type, const char *format, ...)
{
    va_list args;
    if (!notification_initialized)
    {
        return;
    }
    Notification notification;
    strncpy(notification.type, type, MAX_SIZE_NOTIFICATION_TYPE);
    va_start(args, format);
    vsnprintf(notification.message, MAX_SIZE_NOTIFICATION_MESSAGE, format, args);
    va_end(args);
    IO_staticQueue_push(&notification_queue, &notification);
    return;
}

// bool notification_send();

#define CMD_WRITE 128
#define CMD_PING 0            // test communication
#define CMD_DATA 1            // send monitor data
#define CMD_STATE 2           // send machine state
#define CMD_MPROFILE 3        // send/recieve machine profile
#define CMD_MCONFIG 4         // send/recieve machine configuration
#define CMD_MPERFORMANCE 5    // send/receive machine performance
#define CMD_MOTIONPROFILE 6   // send/recieve motion profile
#define CMD_MOTIONMODE 7      // send/recieve motion mode
#define CMD_MOTIONFUNCTION 8  // send/recieve motion function and data
#define CMD_MOTIONSTATUS 9    // send/recieve motion status
#define CMD_MOVE 10           // start/send sending motion data
#define CMD_AWK 11            // send/recieve AWK
#define CMD_TESTDATA 12       // send/recieve test data
#define CMD_TESTDATA_COUNT 13 // send/recieve test data count
#define CMD_MANUAL 14         // send/recieve manual control data
#define CMD_SET_GAUGE_LENGTH 15
#define CMD_NOTIICATION 16
#define CMD_RUN 17
#define CMD_SET_GAUGE_FORCE 18
#define CMD_TEST_HEADER 19

#define MAD_VERSION 1

static bool send(int cmd, char *buf, uint16_t size)
{
    DEBUG_INFO("Sending data of size: %d\n", size);

    fds_tx(&fds, 0x55);
    fds_tx(&fds, cmd);
    fds_tx(&fds, size);
    fds_tx(&fds, size >> 8);

    for (int i = 0; i < size; i++)
    {
        fds_tx(&fds, buf[i]);
    }
    unsigned crc = crc8((uint8_t *)buf, size);
    fds_tx(&fds, crc);
    return true;
}

static bool communication_private_recieve_command(uint8_t *cmd)
{
    bool command_recieved = false;
    if (fds_rxcheck(&fds))
    {
        int sync = fds_rxtime(&fds, 10);
        if (sync == 0x55)
        {
            int res = fds_rxtime(&fds, 10);
            if (res > 0)
            {
                *cmd = (uint8_t)res;
                command_recieved = true;
            }
        }
    }
    return command_recieved;
}
static char awk_buf[100]; // Should use json encode buffer
static void send_awk(uint8_t cmd, const char *awk)
{
    snprintf(awk_buf, 100, "{\"cmd\":\"%d\",\"awk\":\"%s\"}", cmd, awk);
    send(CMD_AWK, awk_buf, strlen(awk_buf)); // send ack, 0 is success, 1 is fail, 2 is busy
}

// @TODO RETURN CHECKSUM FOR VALIDATION IT WAS RECIEVED CORRECTLY
static uint16_t receive(uint8_t cmd, char *buf, int max_size)
{
    if (buf == NULL)
    {
        return 0;
    }

    // Read data size
    int res = fds_rxtime(&fds, 10);
    if (res == -1)
    {
        DEBUG_WARNING("%s", "invalid data recieved\n");
        send_awk(cmd, "FAIL");
        return 0;
    }
    uint16_t size = ((uint8_t)res);

    res = fds_rxtime(&fds, 10);
    if (res == -1)
    {
        DEBUG_WARNING("%s", "invalid data recieved\n");
        send_awk(cmd, "FAIL");
        return 0;
    }

    size |= ((uint8_t)res) << 8;

    DEBUG_INFO("Recieved data of size: %d\n", size);

    if (size > max_size - 1)
    {
        DEBUG_WARNING("invalid data recieved, data is larger then buffer: buf=%d, max=%d\n", size, max_size);
        send_awk(cmd, "FAIL");
        return 0;
    }
    // Read data
    for (unsigned int i = 0; i < size; i++)
    {
        buf[i] = fds_rxtime(&fds, 10);
        if (buf[i] == -1)
        {
            DEBUG_WARNING("%s", "invalid data recieved\n");
            send_awk(cmd, "FAIL");
            return 0;
        }
    }

    // Read CRC
    res = fds_rxtime(&fds, 10);
    if (res == -1)
    {
        DEBUG_WARNING("%s", "no crc recieved\n");
        send_awk(cmd, "FAIL");
        return 0;
    }

    uint8_t crc = (uint8_t)res;

    // Check CRC
    if (crc != crc8((uint8_t *)buf, size))
    {
        DEBUG_WARNING("%s", "invalid crc recieved\n");
        send_awk(cmd, "FAIL");
        return 0;
    }

    return size;
}

#define MAX_BUFFER_SIZE 1000
static char recieved_json[MAX_BUFFER_SIZE];

#define MAX_RESPONSE_SIZE 500
static char response_json[MAX_RESPONSE_SIZE]; // REMOVE THIS, should use json encoder buffer

static app_monitor_sample_t test_data_buffer[255];

static void command_respond(uint8_t cmd)
{
    DEBUG_INFO("Responding to command: %d\n", cmd);
    switch (cmd)
    {
    case CMD_PING:
    {
        DEBUG_INFO("%s", "Sending ping with firmware version\n");
        strncpy(response_json, "{\"version\": \"1.0.0\"}", MAX_RESPONSE_SIZE);
        send(CMD_PING, response_json, strlen(response_json) + 1);
        break;
    }
    case CMD_AWK:
    {
        DEBUG_INFO("%s", "Sending delayed awk\n");
        send_awk(cmd, "OK");
        break;
    }
    case CMD_DATA:
    {
        app_monitor_sample_t monitor_data;
        app_monitor_getSample(&monitor_data);
        DEBUG_INFO("Sending Data (%d)\n", monitor_data.index);
        snprintf(response_json, MAX_RESPONSE_SIZE, "{\"Force\":%d,\"Position\":%d,\"Setpoint\":%d,\"Time\":%d,\"Log\":%d, \"Raw\":%d}",
                 monitor_data.force, monitor_data.position, monitor_data.setpoint, monitor_data.time, monitor_data.index, monitor_data.force);
        DEBUG_INFO("Sending: %s\n", response_json);
        send(CMD_DATA, response_json, strlen(response_json)); // dont send null ptr

        break;
    }
    case CMD_STATE:
    {
        DEBUG_INFO("%s", "Sending machine state\n");
        MachineState machine_state;
        get_machine_state(&machine_state);
        char *buf = machine_state_to_json(&machine_state);
        if (buf == NULL)
        {
            DEBUG_ERROR("%s", "Failed to convert machine state to json\n");
            return;
        }
        DEBUG_INFO("Sending: %s\n", buf);
        send(CMD_STATE, buf, strlen(buf));
        unlock_json_buffer();
        break;
    }
    case CMD_MPROFILE:
    {
        DEBUG_INFO("%s", "Sending machine profile\n");

        // Convert to json
        char *buf = machine_profile_to_json(&machineProfile);
        if (buf == NULL)
        {
            DEBUG_ERROR("%s", "Failed to convert machine profile to json\n");
            return;
        }
        DEBUG_INFO("Sending machine profile: %s\n", buf);
        send(CMD_MPROFILE, buf, strlen(buf));
        unlock_json_buffer();
        break;
    }
    case CMD_SET_GAUGE_LENGTH:
    {
        DEBUG_WARNING("%s", "Setting gauge\n");
        app_monitor_setGaugeLength();
        break;
    }
    case CMD_SET_GAUGE_FORCE:
    {
        DEBUG_WARNING("%s", "Setting gauge Force\n");
        app_monitor_setGaugeForce(); // should be outputs
        break;
    }
    case CMD_RUN:
    {
        DEBUG_INFO("%s", "Attempting to run Test\n");
        // monitor_run_test();
        break;
    }
    default:
    {
        DEBUG_WARNING("Write Command not found: %d\n", cmd);
        break;
    }
    }
}

void command_recieve(uint8_t cmd)
{
    DEBUG_INFO("%s", "Recieving Data from command\n");
    if (receive(cmd, recieved_json, MAX_BUFFER_SIZE) == 0)
    {
        DEBUG_WARNING("%s", "failed to receive command data\n");
        return;
    }
    DEBUG_INFO("Recieved: %s\n", recieved_json);
    switch (cmd)
    {
    case CMD_MPROFILE:
    {
        DEBUG_INFO("%s", "Getting machine profile\n");
        MachineProfile temp;
        if (!json_to_machine_profile(&temp, recieved_json))
        {
            DEBUG_WARNING("%s", "failed to parse machine profile\n");
            break;
        }

        dev_nvram_updateChannelData(DEV_NVRAM_CHANNEL_MACHINE_PROFILE, &temp, sizeof(MachineProfile));
        // should have this notify once it successfully writes to NVRAM
        DEBUG_NOTIFY("%s", "Machine profile saved to SD Card, please reboot\n");
#ifndef __EMULATION__
        _reboot(); //-- need to reenable, how can I simulate reboot...
#endif
        break;
    }
    case CMD_MOTIONMODE:
    {
        DEBUG_INFO("%s", "Getting motion mode\n");

        MotionMode mode;
        if (!json_to_motion_mode(&mode, recieved_json))
        {
            DEBUG_WARNING("%s", "failed to parse motion mode\n");
            break;
        }

        DEBUG_INFO("Setting motion mode: %d\n", mode);
        state_machine_set(PARAM_MOTION_MODE, mode);
        break;
    }
    case CMD_MOTIONSTATUS:
    {
        DEBUG_INFO("%s", "Getting motion status\n");
        MotionStatus status;

        if (!json_to_motion_status(&status, recieved_json))
        {
            DEBUG_WARNING("%s", "failed to parse motion status\n");
            break;
        }

        state_machine_set(PARAM_MOTION_STATUS, status);

        break;
    }
    case CMD_MOVE:
    {
        DEBUG_INFO("%s", "Getting test command\n");

        app_motion_move_t move;
        if (json_to_move(&move, recieved_json))
        {
            if (app_motion_addManualMove(&move))
            {
                DEBUG_INFO("%s", "move added\n");
                send_awk(CMD_MOVE, "OK");
                break;
            }
            else
            {
                send_awk(CMD_MOVE, "BUSY");
                break;
            }
        }
        else
        {
            send_awk(CMD_MOVE, "FAIL");
            DEBUG_ERROR("%s", "failed to parse test command\n");
            break;
        }
        break;
    }
    case CMD_MANUAL:
    {
        DEBUG_INFO("Getting manual command: %s\n", recieved_json);

        app_motion_move_t move;
        if (json_to_move(&move, recieved_json))
        {
            if (app_motion_addManualMove(&move))
            {
                DEBUG_INFO("Adding move G:%d X%f F%f\n", move.g, move.x, move.f);
            }
            else
            {
                DEBUG_WARNING("%s", "failed to add move\n");
                break;
            }
        }
        else
        {
            DEBUG_ERROR("%s", "failed to parse manual command\n");
            break;
        }
        break;
    }
    case CMD_TESTDATA:
    {
        /* DEBUG_INFO("%s","Sending test data\n");

         TestDataRequest req;
         if (!json_to_test_data_request(&req, recieved_json))
         {
             DEBUG_ERROR("%s","Failed to convert json to test data request\n");
             return;
         }
         DEBUG_INFO("Sending test data: index=%d, count=%d\n", req.index, req.count);
         if (read_sd_card_data(test_data_buffer, req.index, req.count) != 0)
         {
             char *buf = test_data_to_json(test_data_buffer, req.count, req.index);
             if (buf == NULL)
             {
                 DEBUG_ERROR("%s","Failed to convert test data to json\n");
                 return;
             }
             send(CMD_TESTDATA, buf, strlen(buf));
             unlock_json_buffer();
         }*/
        break;
    }
    case CMD_TEST_HEADER:
    {
        DEBUG_INFO("%s", "Recieving test header\n");

        /*if (!monitor_set_header(recieved_json))
        {
            send_awk(CMD_TEST_HEADER, "FAIL");
        }*/

        const char *name;
        if (!json_to_test_header_name(&name, recieved_json))
        {
            DEBUG_ERROR("%s", "Failed to get name for test header\n");
            return;
        }
        // monitor_set_test_name(name);
        app_motion_clearMoveQueue(); // clear any remaining motion test moves before new profile
        unlock_json_buffer();
        send_awk(CMD_TEST_HEADER, "OK");
        break;
    }
    default:
    {
        DEBUG_WARNING("%s", "unknown command\n");
        break;
    }
    }
}

static void beginCommunication(void *arg)
{
    _waitms(500); // wait for monitor to start, should be replaced by cog status!
    // Begin main loop
    fds_start(&fds, RPI_RX, RPI_TX, 0, 115200);
    dev_nvram_getChannelData(DEV_NVRAM_CHANNEL_MACHINE_PROFILE, &machineProfile, sizeof(MachineProfile));
    while (1)
    {
        // Let watchdog know we are running ok
        watchdog_kick(WATCHDOG_CHANNEL_COMMUNICATION);

        // Process any incommand commands over serial
        uint8_t cmd = 0;
        const bool command_recieved = communication_private_recieve_command(&cmd);
        if (command_recieved)
        {
            DEBUG_INFO("cmd:%d,write:%d\n", (cmd & ~CMD_WRITE), ((cmd & CMD_WRITE) == CMD_WRITE));
            if ((cmd & CMD_WRITE) != CMD_WRITE)
            {
                command_respond(cmd);
            }
            else
            {
                command_recieve(cmd & ~CMD_WRITE);
            }
        }

        // Send any notifications
        Notification notification;
        if (IO_staticQueue_pop(&notification_queue, &notification))
        {
            char *notification_json = notification_to_json(&notification);
            if (notification_json == NULL)
            {
                continue;
            }
            send(CMD_NOTIICATION, notification_json, strlen(notification_json));
            unlock_json_buffer();
        }

        // Send periodic data

        for (PeriodicMessages message = 0; message < PERIOD_MESSAGE_COUNT; message++)
        {
            if ((_getms() - periodic_messages[message].last_sent) > periodic_messages[message].period)
            {
                command_respond(periodic_messages[message].command);
                periodic_messages[message].last_sent = _getms();
            }
        }
    }
}

bool start_communication()
{
    // Start communication cog
    int id = _cogstart_C(beginCommunication, NULL, &comm_stack[0], sizeof(long) * COMMUNICATION_MEMORY_SIZE);
    return id != -1;
}
